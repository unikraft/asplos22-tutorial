<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>Inside the Config and Build System - ASPLOS'22 Tutorial</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Unikraft ASPLOS'22 Tutorial"><meta property="og:title" content="Unikraft ASPLOS'22 Tutorial"><meta property="og:type" content="website"><meta property="og:url" content="https://asplos22.unikraft.org"><meta property="og:description" content="ASPLOS'22 Tutorial on Unikraft: educating the community on unikernels, libOSes, and particularly Unikraft."><meta name=twitter:card content="summary"><meta name=twitter:site content="@UnikraftSDK"><meta name=twitter:creator content="@UnikraftSDK"><link rel=icon href=/favicon.png><link rel=stylesheet href=/css/style.min.9d91cadd6bf9a027131051416b1155705f1a4ce3735fcdef7072384726bf9590.css></head><body class="page page-default-single"><div id=main-menu-mobile class=main-menu-mobile><ul><li class="menu-item-learn more about unikraft"><a href=https://unikraft.org><span>Learn more about Unikraft</span></a></li></ul></div><div class=wrapper><div class=header><div class=container><div class=logo><a href=/><img alt=Logo src=/images/unikraft.svg>
<span>ASPLOS'22 Tutorial</span></a></div><div class=logo-mobile><a href=/><img alt=Logo src=/images/unikraft.svg>
<span>ASPLOS'22 Tutorial</span></a></div><div id=main-menu class=main-menu><ul><li class="menu-item-learn more about unikraft"><a href=https://unikraft.org><span>Learn more about Unikraft</span></a></li></ul></div><button id=toggle-main-menu-mobile class="hamburger hamburger--slider" type=button>
<span class=hamburger-box><span class=hamburger-inner></span></span></button></div></div><div class="container pt-2 pt-md-4 pb-3 pb-md-6"><div class=row><div class="col-12 col-md-3 mb-3"><div class=sidebar><div class=docs-menu><h4></h4><ul><li><a href=/intro/>Introduction</a></li><li><a href=/getting-started/>Getting started with Unikraft</a></li><li class=active><a href=/a-look-inside/>Inside the Config and Build System</a></li><li><a href=/complex-apps/>Running complex applications</a></li><li><a href=/syscall_shim-bincompat/>Syscall Shim and Binary Compatibility Layer</a></li><li><a href=/high-performance/>High performance applications</a></li><li><a href=/current-research-and-dev/>Unikernels: Paths to Production & Current Research Trends</a></li><li><a href=/people/>People</a></li></ul></div></div></div><div class="col-12 col-md-9"><h1 class=title>Inside the Config and Build System</h1><div class=content><h2 id=required-tools-and-resources>Required Tools and Resources</h2><p>For this session, the following tools are needed: <code>qemu-kvm</code>, <code>qemu-system-x86_64</code>, <code>qemu-system-aarch64</code>, <code>gcc-aarch64-linux-gnu</code>.
To install on Debian/Ubuntu use the following command</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo apt-get -y install qemu-kvm qemu-system-x86 qemu-system-arm gcc-aarch64-linux-gnu
</code></pre></div><h2 id=overview>Overview</h2><h3 id=01-linuxu-and-kvm>01. linuxu and KVM</h3><p>Unikraft can be run in 2 ways:</p><ul><li>As a virtual machine, using QEMU/KVM or Xen.
It acts as an operating system, having the responsibility to configure the hardware components that it needs (clocks, additional processors, etc).
This mode gives Unikraft direct and total control over hardware components, allowing advanced functionalities.</li><li>As a <code>linuxu</code> build, in which it behaves as a Linux user-space application.
This severely limits its performance, as everything Unikraft does must go through the Linux kernel, via system calls.
This mode should be used only for development and debugging.</li></ul><p>When Unikraft is running using QEMU/KVM, it can either be run on an emulated system or a (para)virtualized one.
Technically, KVM means virtualization support is enabled.
If using QEMU in emulated mode, KVM is not used.
To keep things simple, we will use interchangeably the terms QEMU, KVM or QEMU/KVM to refer to this use (either virtualized, or emulated).</p><p>Emulation is slower, but it allows using CPU architectures different from the local one (you can run ARM code on a x86 machine).
Using (para)virtualisation, aka hardware acceleration, greater speed is achieved and more hardware components are visible to Unikraft.</p><h3 id=02-unikraft-core>02. Unikraft Core</h3><p>The Unikraft core is comprised of several components:</p><ul><li><a href=https://github.com/unikraft/unikraft/tree/staging/arch>the architecture code</a>:
This defines behaviours and hardware interactions specific to the target architecture (x86_64, ARM, RISC-V).
For example, for the x86_64 architecture, this component defines the usable registers, data types sizes and how Thread-Local Storage should happen.</li><li><a href=https://github.com/unikraft/unikraft/tree/staging/plat>the platform code</a>:
This defines interaction with the underlying hardware, depending on whether a hypervisor is present or not, and which hypervisor is present.
For example, if the KVM hypervisor is present, Unikraft will behave almost as if it runs bare-metal, needing to initialize the hardware components according to the manufacturer specifications.
The difference from bare-metal is made only at the entry, where some information, like the memory layout, the available console, are supplied by the bootloader (Multiboot) and there&rsquo;s no need to interact with the BIOS or UEFI.
In the case of Xen, many of the hardware-related operations must be done through hypercalls, thus reducing the direct interaction of Unikraft with the hardware.</li><li><a href=https://github.com/unikraft/unikraft/tree/staging/lib>internal libraries</a>:
These define behaviour independent of the hardware, like scheduling, networking, memory allocation, basic file systems.
These libraries are the same for every platform or architecture, and rely on the platform code and the architecture code to perform the needed actions.
The internal libraries differ from the external ones in the implemented functionalities.
The internal ones define parts of the kernel, while the external ones define user-space level functionalities.
For example, <strong>uknetdev</strong> and <strong>lwip</strong> are 2 libraries that define networking components.
<a href=https://github.com/unikraft/unikraft/tree/staging/lib/uknetdev>uknetdev</a> is an internal library that interacts with the network card and defines how packages are sent using it.
<a href=https://github.com/unikraft/lib-lwip>lwip</a> is an external library that defines networking protocols, like IP, TCP, UDP.
This library knows that the packages are somehow sent over the NIC, but it is not concerned how.
That is the job of the kernel.</li></ul><h3 id=03-libc-in-unikraft>03. libc in Unikraft</h3><p>The Unikraft core provides only the bare minimum components to interact with the hardware and manage resources.
A software layer, similar to the standard C library in a general-purpose OS, is required to make it easy to run applications on top of Unikraft.</p><p>Unikraft has multiple variants of a libc-like component:</p><ul><li><a href=https://github.com/unikraft/unikraft/tree/staging/lib/nolibc>nolibc</a> is a minimalistic libc, part of the core Unikraft code, that contains only the functionality needed for the core (strings, qsort, etc).</li><li><a href=https://github.com/unikraft/unikraft/tree/staging/lib/isrlib>isrlib</a> is the interrupt-context safe variant of nolibc.
It is used for interrupt handling code.</li><li><a href=https://github.com/unikraft/lib-newlib>newlibc</a> is the most complete libc currently available for Unikraft, but it still lacks some functionalities, like multithreading.
Newlibc was designed for embedded environments.</li><li><a href=https://github.com/unikraft/lib-musl>musl</a> is, theoretically, the best libc that will be used by Unikraft, but it&rsquo;s currently in testing.</li></ul><p>Nolibc and isrlib are part of the Unikraft core.
Newlibc and musl are external libraries, from the point of view of Unikraft, and they must be included to the build.</p><h3 id=04-configuring-unikraft---configuk>04. Configuring Unikraft - Config.uk</h3><p>Unikraft is a configurable operating system, where each component can be modified, configured, according to the userâ€™s needs.
This configuration is done using a version of Kconfig, through the <strong>Config.uk</strong> files.
In these files, options are added to enable libraries, applications and different components of the Unikraft core.
The user can then apply those configuration options, using <code>make menuconfig</code>, which generates an internal configuration file that can be understood by the build system, <strong>.config</strong>.
Once configured, the Unikraft image can be built, using <code>make</code>, and run, using the appropriate method (Linux ELF loader, qemu-kvm, xen, others).</p><p>Configuration can be done in 3 ways:</p><ul><li><p>Manually, using</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div></li><li><p>Adding a dependency in <strong>Config.uk</strong> for a component, so that the dependency gets automatically selected when the component is enabled.
This is done using <code>depends on</code> and <code>select</code> keywords in <strong>Config.uk</strong>.
The configuration gets loaded and the <strong>.config</strong> file is generated by running</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div><p>This type of configuration removes some configuration steps, but not all of them.</p></li><li><p>Writing the desired configuration in <strong>kraft.yaml</strong>.
The configuration gets loaded and the <strong>.config</strong> file is generated by running</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft configure
</code></pre></div></li></ul><p>In this session, we will use the first and the last configuration options.</p><h3 id=05-the-build-system---basics>05. The Build System - basics</h3><p>Once the application is configured, in <strong>.config</strong>, symbols are defined (e.g. <code>CONFIG_ARCH_X86_64</code>).
Those symbols are usable both in the C code, to include certain functionalities only if they were selected in the configuring process, and in the actual building process, to include / exclude source files, or whole libraries.
This last thing is done in <strong>Makefile.uk</strong>, where source code files are added to libraries.
During the build process, all the <code>Makefile.uk</code> files (from the Unikraft core and external libraries) are evaluated, and the selected files are compiled and linked, to form the Unikraft image.</p><table><thead><tr><th style=text-align:center><img src=/a-look-inside/images/build_uk.svg alt="unikraft build"></th></tr></thead><tbody><tr><td style=text-align:center>The build process of Unikraft</td></tr></tbody></table><h2 id=summary>Summary</h2><ul><li>Unikraft is a special type of operating system, that can be configured to match the needs of a specific application.</li><li>This configuration is made possible by a system based on Kconfig, that uses <strong>Config.uk</strong> files to add possible configurations, and <strong>.config</strong> files to store the specific configuration for a build.</li><li>The configuration step creates symbols that are visible in both Makefiles and source code.</li><li>Each component has its own <strong>Makefile.uk</strong>, where source files can be added, removed, or be made dependent on the configuration.</li><li>Unikraft has an internal libc, but it can use others, more complex and complete, like newlib and musl.</li><li>Being an operating system, it needs to be run by a hypervisor, like KVM, xen, to work at full capacity.
It can also be run as an ELF, in Linux, but in this way the true power of Unikraft is not achieved.</li></ul><h2 id=work-items>Work Items</h2><h3 id=support-files>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/asplos22-tutorial>in the repository</a>.
The repository is already cloned in the virtual machine.</p><p>If you want to clone the repository yourself, do</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ git clone https://github.com/unikraft/asplos22-tutorial

$ cd asplos22-tutorial/content/a-look-inside/

$ ls
images/  index.md  sol/  work/
</code></pre></div><h3 id=01-tutorial--reminder-building-and-running-unikraft>01. Tutorial / Reminder: Building and Running Unikraft</h3><p>We want to build the <code>helloworld</code> application, using the Kconfig-based system, for the <strong>linuxu</strong> and <strong>KVM</strong> platforms, for the <strong>ARM</strong> and <strong>x86</strong> architectures, and then run them.</p><p>The <code>unikraft</code> and <code>app-helloworld</code> repsitories are already created in the virtual machine, in the <code>a-look-inside/</code> folder, in a typical development hierarchy:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>a-look-inside/
`-- apps/
|   `-- helloworld/
|-- libs/
`-- unikraft/
</code></pre></div><p>See the <code>UK_ROOT</code> and <code>UK_LIBS</code> in the <code>apps/helloworld/Makefile</code>, pointing to the <code>unikraft</code> repository and the library folder:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>UK_ROOT ?= $(PWD)/../../unikraft
UK_LIBS ?= $(PWD)/../../libs
</code></pre></div><h4 id=linuxu-x86_64>Linuxu, x86_64</h4><p>First, we will build the image for the <strong>linuxu</strong> platform.
As the resulting image will be an ELF, we can only run the <strong>x86</strong> Unikraft image.
We follow the steps:</p><ol><li><p>Enter the <code>helloworld</code> folder:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd apps/helloworld
</code></pre></div></li><li><p>Clean up all configuration and build files:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make distclean
</code></pre></div></li><li><p>Configure the application by running</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div><ol><li><p>From <code>Architecture Selection</code>, select <code>Architecture</code> -> <code>x86 compatible</code>.</p></li><li><p>From <code>Platform Configuration</code>, select <code>Linux user space</code>.</p></li><li><p>Save, exit and run</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make
</code></pre></div></li></ol></li><li><p>The resulting image, <code>helloworld_linuxu-x86_64</code> is located in the <code>build/</code> folder.
Run it directly, as a Linux executable:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ./build/helloworld_linuxu-x86_64
</code></pre></div></li></ol><h4 id=kvm-x86_64>KVM, x86_64</h4><p>Next, we will build the image for the <strong>kvm</strong> platform.
Before starting the process, make sure that you have the necessary tools, listed in the <a href=/a-look-inside/#required-tools>Required Tools</a> section.
We follow the steps:</p><ol><li><p>Enter the <code>helloworld</code> folder:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd apps/helloworld
</code></pre></div></li><li><p>Clean up all configuration and build files:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make distclean
</code></pre></div></li><li><p>Configure the application by running</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div><ol><li><p>We will leave the architecture as is, for now.</p></li><li><p>From <code>Platform Configuration</code>, select <code>KVM guest</code>.</p></li><li><p>Save, exit and run</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make
</code></pre></div></li></ol></li><li><p>Load the resulting image in QEMU by using</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo qemu-system-x86_64 -kernel ./build/helloworld_kvm-x86_64 -nographic
</code></pre></div></li></ol><p>Besides <code>-serial stdio</code>, no other option is needed to run the <code>helloworld</code> application.
Other, more complex applications, will require more options given to the <code>qemu-system-x86-64</code> command.</p><p>The above command ran the application in QEMU emulation mode.
We can also run it in virtualization mode, by adding the <code>-enable-kvm</code> option.
You may receive a warning, <code>host doesn't support requested feature:</code>.
This is because KVM uses a generic CPU model.
You can instruct KVM to use your local CPU model, by adding <code>-cpu host</code> to the command.</p><p>The final command will look like this:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo qemu-system-x86_64 -enable-kvm -cpu host -kernel ./build/helloworld_kvm-x86_64 -nographic
</code></pre></div><h4 id=kvm-arm>KVM, ARM</h4><p>To configure Unikraft for the ARM architecture, follow the steps:</p><ol><li><p>Enter the <code>helloworld</code> folder:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd apps/helloworld
</code></pre></div></li><li><p>Clean up all configuration and build files:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make distclean
</code></pre></div></li><li><p>Configure the application by running</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div><ol><li><p>From <code>Architecture Selection</code>, select <code>Architecture</code> -> <code>Armv8 compatible</code>.</p></li><li><p>From <code>Platform Configuration</code>, select <code>KVM guest</code>.</p></li><li><p>Save, exit and run</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make
</code></pre></div></li></ol></li><li><p>Load the resulting image in QEMU by using</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo qemu-system-aarch64 -machine virt -cpu cortex-a57 -kernel ./build/helloworld_kvm-arm64 -nographic
</code></pre></div></li></ol><p>Note that now we need to provide a machine and a CPU model to be emulated, as there are no defaults available.
If you want to find information about other machines, run</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo qemu-system-aarch64 -machine help
</code></pre></div><h3 id=02-tutorial--reminder-adding-filesystems-to-an-application>02. Tutorial / Reminder: Adding Filesystems to an Application</h3><p>For this tutorial, the aim is to create a simple QEMU/KVM application that reads from a file and displays the contents to standard output.
A local directory is to be mounted as the root directory (<code>/</code>) inside the QEMU/KVM virtual machine.</p><p>We will use both the manual approach (<code>make</code> and <code>qemu-system-x86_64</code> / <code>qemu-guest</code>) and <code>kraft</code> to configure, build and run the application.</p><h4 id=setup>Setup</h4><p>The basic setup is in the <code>work/02-adding-filesystems/</code> folder in the session directory.
Enter that folder:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd work/02-adding-filesystems/

$ ls -F
guest_fs/  kraft.yaml  launch.sh*  main.c  Makefile  Makefile.uk  qemu-guest*
</code></pre></div><p>The <code>guest_fs/</code> local directory is to be mounted as the root directory (<code>/</code>) inside the QEMU/KVM virtual machine.
It contains the <code>grass</code> file.
The program (<code>main.c</code>) reads the contents of the <code>/grass</code> file and prints it to standard output.
<code>Makefile.uk</code> lists the <code>main.c</code> file as the application source file to be compiled and linked with Unikraft.</p><p><code>Makefile</code> is used by the manual configuration and build system.
<code>kraft.yaml</code> is used by kraft to configure, build and run the application.</p><p><code>launch.sh</code> is a wrapper script around <code>qemu-system-x86_64</code> used to manually run the application.
Similarly, <code>qemu-guest</code> is a wrapper script <a href=https://github.com/unikraft/kraft/blob/staging/scripts/qemu-guest>used internally by <code>kraft</code></a>.
We&rsquo;ll use it as well to run the application.</p><p><strong>If, at any point of this tutorial, something doesn&rsquo;t work, or you want a quick check, see the reference solution in <code>sol/02-adding-filesystems/</code> folder in the session directory.</strong></p><h3 id=using-the-manual-approach>Using the Manual Approach</h3><p>Firstly, we will use the manual approach to configure, build and run the application.</p><h4 id=configure>Configure</h4><p>For filesystem functionalities (opening, reading, writing files) we require a more powerful libc.
<a href=https://github.com/unikraft/lib-newlib>newlib</a> is already ported in Unikraft and will do nicely.
For this, we update the <code>LIBS</code> line in the <code>Makefile</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>LIBS := $(UK_LIBS)/newlib
</code></pre></div><p>Update the <code>UK_ROOT</code> and <code>UK_LIBS</code> variables in the <code>Makefile</code> to point to the folders storing the Unikraft and libraries repositories.
You can use the folders in <code>~/a-look-inside/</code>,</p><p><strong>Make sure that both <code>unikraft</code> and <code>newlib</code> repositories are on the <code>staging</code> branch.</strong>
Go to each of the two repository folders (<code>unikraft</code> and <code>newlib</code>) and check the current branch:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ git status
On branch staging
</code></pre></div><p>Now we need to enable <strong>9pfs</strong> and <strong>newlib</strong> in Unikraft.
To do this, we run:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div><p>We need to select the following options, from the <code>Library Configuration</code> menu:</p><ul><li><code>libnewlib</code></li><li><code>vfscore: VFS Core Interface</code></li><li><code>vfscore: VFS Configuration</code> -> <code>Automatically mount a root filesystem</code> -> <code>Default root filesystem</code> -> <code>9pfs</code><ul><li>For the <code>Default root device</code> option fill the <code>fs0</code> string (instead of the default <code>rootfs</code> string).</li></ul></li></ul><p>These configurations will also mark as required <strong>9pfs</strong> and <strong>uk9p</strong> in the menu.</p><p>We want to run Unikraft with QEMU/KVM, so we must select <strong>KVM guest</strong> in the <code>Platform Configuration</code> menu.
For 9PFS we also need to enable, in the <strong>KVM guest</strong> options menu, <code>Virtio</code> -> <code>Virtio PCI device support</code>.</p><p>Save the configuration and exit.</p><p>Do a quick check of the configuration in <code>.config</code> by pitting it against the <code>config.sol</code> file in the reference solution:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ diff -u .config ../../sol/02-adding-filesytstems/config.sol
</code></pre></div><p>Differences should be minimal, such as the application identifier.</p><h4 id=build>Build</h4><p>Build the Unikraft image:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make
</code></pre></div><p>Building the Unikraft image will take a while.
It has to pull the <code>newlib</code> source code, patch it and then build it, together with the Unikraft source code.</p><h4 id=run-with-qemu-system-x86_64>Run with qemu-system-x86_64</h4><p>To run the Unikraft image with QEMU/KVM, we use the wrapper <code>launch.sh</code> script, that calls <code>qemu-system-x86_64</code> command with the proper arguments:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ./launch.sh ./build/02-adding-filesystems_kvm-x86_64
[...]
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~825b115
Hello, world!
File contents: The grass is green!
Bye, world!
</code></pre></div><p>A completely manual run would use the command:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ qemu-system-x86_64 -fsdev local,id=myid,path=guest_fs,security_model=none -device virtio-9p-pci,fsdev=myid,mount_tag=fs0 -kernel build/02-adding-filesystems_kvm-x86_64 -nographic
[...]
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~825b115
Hello, world!
File contents: The grass is green!
Bye, world!
</code></pre></div><p>Lets break it down:</p><ul><li><code>-fsdev local,id=myid,path=guest_fs,security_model=none</code> - assign an id (<code>myid</code>) to the <code>guest_fs/</code> local folder</li><li><code>-device virtio-9p-pci,fsdev=myid,mount_tag=fs0</code> - create a device with the 9pfs type, assign the <code>myid</code> for the <code>-fsdev</code> option and also assign the mount tag that we configured above (<code>fs0</code>)
Unikraft will look after that mount tag when trying to mount the filesystem, so it is important that the mount tag from the configuration is the same as the one given as argument to qemu.</li><li><code>-kernel build/02-adding-filesystems_kvm-x86_64</code> - tells QEMU that it will run a kernel;
if this parameter is omitted, QEMU will think it runs a raw file</li><li><code>-nographic</code> - prints the output of QEMU to the standard output, it doesn&rsquo;t open a graphical window</li></ul><h4 id=run-with-qemu-guest>Run with qemu-guest</h4><p><a href=https://github.com/unikraft/kraft/blob/staging/scripts/qemu-guest>qemu-guest</a> is the script used by kraft to run its QEMU/KVM images.
Before looking at the command, take some time to look through the script, and maybe figure out the arguments needed for our task.</p><p>To run a QEMU/KVM application using <code>qemu-guest</code>, we use:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ./qemu-guest -e guest_fs/ -k build/02-adding-filesystems_kvm-x86_64
</code></pre></div><p>If we add the <code>-D</code> option, we can see the <code>qemu-system</code> command generated.</p><p>You may get the following error:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>[    0.100664] CRIT: [libvfscore] &lt;rootfs.c @  122&gt; Failed to mount /: 22
</code></pre></div><p>If you do, check that the mount tag in the configuration is the same as the one used by <code>qemu-guest</code>.
<code>qemu-guest</code> will use the tag <code>fs0</code>.</p><p><strong>The <code>fs0</code> tag is hardcoded for <code>qemu-guest</code> (and, thus, for <code>kraft</code>).
This is why we used the <code>fs0</code> tag when configuring the application with <code>make menuconfig</code>.
Another tag could be used but then we couldn&rsquo;t run the application with <code>qemu-guest</code> or <code>kraft</code>.
It could only be run by manually using <code>qemu-system-x86_64</code> with the corresponding arguments.</strong></p><h3 id=using-kraft>Using kraft</h3><p>With kraft, the whole process of configuring, building and running Unikraft can be made easier.</p><p>By default, kraft uses the <code>~/.unikraft/</code> folder where all the repositories are cloned.
As we want to use the repositories in <code>~/a-look-inside/</code>, we fill the <code>UK_WORKDIR</code> variable:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ export UK_WORKDIR=~/a-look-inside/
</code></pre></div><p>And clean up the build workplace:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make distclean
</code></pre></div><h4 id=configure-1>Configure</h4><p>First, we need to replace the <code>TODO</code> lines in <strong>kraft.yaml</strong>, to reflect our new configuration.
The first set of <code>TODO</code> lines correspond to the Unikraft configuration.
They are used by the <code>kraft configure</code> command.
This is the equivalent of what <code>make menuconfig</code> does.
We need to update those <code>TODO</code> lines with:</p><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=w>  </span><span class=nt>kconfig</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=l>CONFIG_LIBUK9P=y</span><span class=w>
</span><span class=w>    </span>- <span class=l>CONFIG_LIB9PFS=y</span><span class=w>
</span><span class=w>    </span>- <span class=l>CONFIG_LIBVFSCORE_AUTOMOUNT_ROOTFS=y</span><span class=w>
</span><span class=w>    </span>- <span class=l>CONFIG_LIBVFSCORE_ROOTFS_9PFS=y</span><span class=w>
</span><span class=w>    </span>- <span class=l>CONFIG_LIBVFSCORE_ROOTDEV=&#34;fs0&#34;</span><span class=w>
</span></code></pre></div><p>Then, we need to update the <code>TODO</code> lines for the volume configuration (for mounting the filesystem).
These configuration lines are to be used by the <code>kraft run</code> command.
We need to update those <code>TODO</code> lines with:</p><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>guest_fs</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>driver</span><span class=p>:</span><span class=w> </span><span class=l>9pfs</span><span class=w>
</span></code></pre></div><p>In the end, the resulting <code>kraft.yaml</code> file will look like this:</p><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nn>---</span><span class=w>
</span><span class=w></span><span class=nt>specification</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;0.5&#39;</span><span class=w>
</span><span class=w></span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=m>02</span>-<span class=l>adding-filesystems</span><span class=w>
</span><span class=w></span><span class=nt>unikraft</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;staging&#39;</span><span class=w>
</span><span class=w>  </span><span class=nt>kconfig</span><span class=p>:</span><span class=w>
</span><span class=w>    </span>- <span class=l>CONFIG_LIBUK9P=y</span><span class=w>
</span><span class=w>    </span>- <span class=l>CONFIG_LIB9PFS=y</span><span class=w>
</span><span class=w>    </span>- <span class=l>CONFIG_LIBVFSCORE_AUTOMOUNT_ROOTFS=y</span><span class=w>
</span><span class=w>    </span>- <span class=l>CONFIG_LIBVFSCORE_ROOTFS_9PFS=y</span><span class=w>
</span><span class=w>    </span>- <span class=l>CONFIG_LIBVFSCORE_ROOTDEV=&#34;fs0&#34;</span><span class=w>
</span><span class=w></span><span class=nt>targets</span><span class=p>:</span><span class=w>
</span><span class=w>  </span>- <span class=nt>architecture</span><span class=p>:</span><span class=w> </span><span class=l>x86_64</span><span class=w>
</span><span class=w>    </span><span class=nt>platform</span><span class=p>:</span><span class=w> </span><span class=l>kvm</span><span class=w>
</span><span class=w></span><span class=nt>libraries</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>newlib</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;staging&#39;</span><span class=w>
</span><span class=w>    </span><span class=nt>kconfig</span><span class=p>:</span><span class=w>
</span><span class=w>      </span>- <span class=l>CONFIG_LIBNEWLIBC=y</span><span class=w>
</span><span class=w></span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>guest_fs</span><span class=p>:</span><span class=w>
</span><span class=w>    </span><span class=nt>driver</span><span class=p>:</span><span class=w> </span><span class=l>9pfs</span><span class=w>
</span></code></pre></div><p>Next, we will make kraft reconfigure our application:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft configure
</code></pre></div><p>In our case, nothing should be modified in <code>.config</code>, as we had the same configuration before.
If you get an error like &ldquo;missing component: newlib&rdquo;, you may need to run <code>kraft list update</code>.</p><h4 id=build-1>Build</h4><p>We can now build the application using:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft build
</code></pre></div><h4 id=run>Run</h4><p>Run the application using:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft run
</code></pre></div><p><strong>Note</strong>: This step is not currently working due to <a href=https://github.com/unikraft/kraft/issues/71>a kraft issue</a>.
You can use the fix described in the issue (and the <a href=https://github.com/unikraft/kraft/pull/72>corresponding pull request</a>)to make <code>kraft run</code> work.</p><h3 id=03-tutorial-make-it-speak>03. Tutorial: Make It Speak</h3><p>The goal of this exercise is to enable the internal debugging library for Unikraft (<code>ukdebug</code>) and make it display messages up to the <em>info</em> level.
We also want to identify which hardware components are initialized for both x86 and ARM, and where.
Go to the <code>helloworld/</code> application folder:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd ~/a-look-inside/apps/helloworld/
</code></pre></div><h4 id=x86_64>x86_64</h4><p>We need to enable <code>ukdebug</code> in the configuration menu:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div><p>It is located in the <code>Library Configuration</code> menu.
Enter the <code>ukdebug</code> configuration menu.
We need to have <code>Enable kernel messages (uk_printk)</code> checked.
Also, we need to change the option below it, <code>Kernel message level</code>, from <code>Show critical and error messages (default)</code> to <code>Show all types of messages</code>.
To make thing prettier, also enable the <code>Colored output</code> option.
After updating the configuration, build Unikraft:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make
</code></pre></div><p>And run in under QEMU/KVM.</p><p>The output differs.
We can see that, in the case of x86, the platform library initializes less components, or it is less verbose than the ARM one.
But the timer and bus initialization is more verbose.
We see what timer is used, the i8254 one.
Also, we see that the PCI bus is used.</p><h4 id=arm>ARM</h4><p>For the ARM part, just change the architecture in the configuration interface:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div><p>After changing the architecture, we have to clean the previously compiled files:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make clean
</code></pre></div><p>Build Unikraft:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make
</code></pre></div><p>We have a bunch of initializations happening, before seeing the &ldquo;Hello world!&rdquo; message.
Let&rsquo;s break them down. We start with the platform internal library, <code>libkvmplat</code>.
Here, the hardware components are initialized, like the Serial module, <code>PL001 UART</code>, and the <code>GIC</code>, which is the interrupt controller.
After that, the memory address space is defined, and the booting process starts, by replacing the current stack with a larger one, that is part of the defined address space.
Lastly, before calling the main function of the application, the software components of Unikraft are initialized, like timers, interrupts, and bus handlers.
The execution ends in in the platform library, with the shutdown command.</p></div></div></div></div></div></div><footer class=sub-footer><div class="container py-5"><div class=row><div class="col-12 col-md">Unikraft
<small class="d-block mb-3 text-muted">Â© 2021</small></div><div class="col-6 col-md"><h5>Social</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://twitter.com/UnikraftSDK>Twitter</a></li><li><a class=text-muted href=https://www.linkedin.com/company/unikraft-sdk/>LinkedIn</a></li></ul></div><div class="col-6 col-md"><h5>&nbsp;</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://bit.ly/UnikraftDiscord>Discord</a></li><li><a class=text-muted href=https://github.com/unikraft/unikraft>GitHub</a></li></ul></div><div class="col-6 col-md"><h5>Resources</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://unikraft.org>Unikraft Homepage</a></li><li><a class=text-muted href=https://unikraft.io>Unikraft Cloud</a></li></ul></div><div class="col-6 col-md"><h5>&nbsp;</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=http://docs.unikraft.org>Documentation</a></li><li><a class=text-muted href=https://unikraft.org/license/>Open-Source Licenses</a></li></ul></div></div></footer></div><script type=text/javascript src=/js/scripts.min.eaf147370baecdd07c022597db631f99cab1c9cd6479de586f30327a568d6a0f.js></script></body></html>