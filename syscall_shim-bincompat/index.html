<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>Syscall Shim and Binary Compatibility Layer - ASPLOS'22 Tutorial</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Unikraft ASPLOS'22 Tutorial"><meta property="og:title" content="Unikraft ASPLOS'22 Tutorial"><meta property="og:type" content="website"><meta property="og:url" content="https://asplos22.unikraft.org"><meta property="og:description" content="ASPLOS'22 Tutorial on Unikraft: educating the community on unikernels, libOSes, and particularly Unikraft."><meta name=twitter:card content="summary"><meta name=twitter:site content="@UnikraftSDK"><meta name=twitter:creator content="@UnikraftSDK"><link rel=icon href=/favicon.png><link rel=stylesheet href=/css/style.min.9d91cadd6bf9a027131051416b1155705f1a4ce3735fcdef7072384726bf9590.css></head><body class="page page-default-single"><div id=main-menu-mobile class=main-menu-mobile><ul><li class="menu-item-learn more about unikraft"><a href=https://unikraft.org><span>Learn more about Unikraft</span></a></li></ul></div><div class=wrapper><div class=header><div class=container><div class=logo><a href=/><img alt=Logo src=/images/unikraft.svg>
<span>ASPLOS'22 Tutorial</span></a></div><div class=logo-mobile><a href=/><img alt=Logo src=/images/unikraft.svg>
<span>ASPLOS'22 Tutorial</span></a></div><div id=main-menu class=main-menu><ul><li class="menu-item-learn more about unikraft"><a href=https://unikraft.org><span>Learn more about Unikraft</span></a></li></ul></div><button id=toggle-main-menu-mobile class="hamburger hamburger--slider" type=button>
<span class=hamburger-box><span class=hamburger-inner></span></span></button></div></div><div class="container pt-2 pt-md-4 pb-3 pb-md-6"><div class=row><div class="col-12 col-md-3 mb-3"><div class=sidebar><div class=docs-menu><h4></h4><ul><li><a href=/intro/>Introduction to Unikraft</a></li><li><a href=/getting-started/>Getting started with Unikraft</a></li><li><a href=/a-look-inside/>Inside the Config and Build System</a></li><li><a href=/complex-apps/>Running complex applications</a></li><li class=active><a href=/syscall_shim-bincompat/>Syscall Shim and Binary Compatibility Layer</a></li><li><a href=/high-performance/>High performance applications</a></li><li><a href=/current-research-and-dev/>Unikernels: Paths to Production & Current Research Trends</a></li><li><a href=/people/>People</a></li></ul></div></div></div><div class="col-12 col-md-9"><h1 class=title>Syscall Shim and Binary Compatibility Layer</h1><div class=content><p>In this session we are going to understand how we can run applications using the binary compatibility layer as well as the inner workings of the system call shim layer.</p><p>One of the obstacles when trying to use Unikraft could be the porting effort of your application.
One way we can avoid this is through binary compatibility.
Binary compatibility is the possibility to take already compiled binaries and run them on top of Unikraft without porting effort and at the same time keeping the benefits of unikernels.
In our case, we support binaries compiled for the Linux kernel.</p><p>In order to achieve binary compatibility with the Linux kernel, we had to find a way to have support for system calls, for this, the <strong>system call shim layer</strong> (also called <strong>syscall shim</strong>) was created.
The system call shim layer provides Linux-style mappings of system call numbers to actual system call handler functions.</p><h2 id=reminders>Reminders</h2><h3 id=configuring-building-and-running-unikraft>Configuring, Building and Running Unikraft</h3><p>At this stage, you should be familiar with the steps of configuring, building and running any application within Unikraft and know the main parts of the architecture.
Below you can see a list of the commands you have used so far.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>kraft list</code></td><td>Get a list of all components that are available for use with kraft</td></tr><tr><td><code>kraft up -t &lt;appname> &lt;your_appname></code></td><td>Download, configure and build existing components into unikernel images</td></tr><tr><td><code>kraft run</code></td><td>Run resulting unikernel image</td></tr><tr><td><code>kraft init -t &lt;appname></code></td><td>Initialize the application</td></tr><tr><td><code>kraft configure</code></td><td>Configure platform and architecture (interactive)</td></tr><tr><td><code>kraft configure -p &lt;plat> -m &lt;arch></code></td><td>Configure platform and architecture (non-interactive)</td></tr><tr><td><code>kraft build</code></td><td>Build the application</td></tr><tr><td><code>kraft clean</code></td><td>Clean the application</td></tr><tr><td><code>kraft clean -p</code></td><td>Clean the application, fully remove the <code>build/</code> folder</td></tr><tr><td><code>make clean</code></td><td>Clean the application</td></tr><tr><td><code>make properclean</code></td><td>Clean the application, fully remove the <code>build/</code> folder</td></tr><tr><td><code>make distclean</code></td><td>Clean the application, also remove <code>.config</code></td></tr><tr><td><code>make menuconfig</code></td><td>Configure application through the main menu</td></tr><tr><td><code>make</code></td><td>Build configured application (in <code>.config</code>)</td></tr><tr><td><code>qemu-guest -k &lt;kernel_image></code></td><td>Start the unikernel</td></tr><tr><td><code>qemu-guest -k &lt;kernel_image> -e &lt;directory></code></td><td>Start the unikernel with a filesystem mapping of <code>fs0</code> id from <code>&lt;directory></code></td></tr><tr><td><code>qemu-guest -k &lt;kernel_image> -g &lt;port> -P</code></td><td>Start the unikernel in debug mode, with GDB server on port <code>&lt;port></code></td></tr></tbody></table><h3 id=system-calls>System Calls</h3><p>A system call is the programmatic way in which a process requests a privileged service from the kernel of the operating system.</p><p>A system call is not a function, but specific assembly instructions that do the following:</p><ul><li>setup information to identify the system call and its parameters</li><li>trigger a kernel mode switch</li><li>retrieve the result of a system call</li></ul><p>In Linux, system calls are identified by a system call ID (a number) and the parameters for system calls are machine word sized (32 or 64 bit).
There can be a maximum of 6 system call parameters.
Both the system call number and the parameters are stored in certain registers.</p><p>For example, on 32bit x86 architecture, the system call identifier is stored in the <code>EAX</code> register, while parameters in registers <code>EBX</code>, <code>ECX</code>, <code>EDX</code>, <code>ESI</code>, <code>EDI</code>, <code>EBP</code>.</p><p>Usually an application does not make a system call directly, but call functions in the system libraries (e.g. libc) that implement the actual system call.</p><p>Let&rsquo;s take an example that you can see in the below image:</p><ol><li>Application program makes a system call by invoking a wrapper function in the C library.</li><li>Each system call has a unique call number which is used by kernel to identify which system call is invoked.
The wrapper function again copies the system call number into specific CPU registers</li><li>The wrapper function takes care of copying the arguments to the correct registers.</li><li>Now the wrapper function executes trap instruction (<code>int 0x80</code> or <code>syscall</code> or <code>sysenter</code>).
This instruction causes the processor to switch from <em>user mode</em> to <em>kernel mode</em>.</li><li>We reach a trap handler, that will call the correct kernel function based on the id we passed.</li><li>The system call service routine is called.</li></ol><p><img src=https://qph.fs.quoracdn.net/main-qimg-0cb5c3a6e1fd7642ac988badc7598c0c alt=system_call_image></p><p>Now, let&rsquo;s take a quick look at unikernels.
As stated above, in Linux, we use system calls to talk to the operating system, but there is a slight problem.
The system calling process adds some overhead to our application, because we have to do all the extra operations to switch from <em>user space</em> to <em>kernel space</em>.
In unikernels, because we don&rsquo;t have a delimitation between <em>kernel space</em> and <em>user space</em> we do not need system calls so everything can be done as simple function calls.
This is both good and bad.
It is good because we do not get the overhead that Linux does when doing a system call.
At the same time it is bad because we need to find a way to support applications that are compiled on Linux, so application that do system calls, even though we don&rsquo;t need them.</p><h2 id=overview>Overview</h2><h3 id=01-the-process-of-loading-and-running-an-application-with-binary-compatibility>01. The Process of Loading and Running an Application with Binary Compatibility</h3><p>For Unikraft to achieve binary compatibility there are two main objectives that need to be met:</p><ol><li>The ability to pass the binary to Unikraft</li><li>The ability to load the binary into memory and jump to its entry point.</li></ol><p>For the first point we decided to use the initial ramdisk in order to pass the binary to the unikernel.
With <code>qemu-guest</code>, in order to pass an initial ramdisk to a virtual machine you have to use the <code>-initrd</code> option.
As an example, if we have a <code>helloworld</code> binary, we can pass it to the unikernel with the following command:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>sudo qemu-guest -kernel build/unikernel_image -initrd helloworld_binary
</code></pre></div><p>After the unikernel gets the binary the next step is to load it into memory.
The dominant format for executables is the <em>Executable and Linkable File</em> format (ELF), so, in order to run executables we need an ELF loader.
The job of the ELF Loader is to load the executable into the main memory.
It does so by reading the program headers located in the ELF formatted executable and acting accordingly.
For example, you can see the program headers of a program by running <code>readelf -l binary</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ readelf -l helloworld_binary

Elf file type is DYN (Shared object file)
Entry point 0x8940
There are 8 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x00000000000c013e 0x00000000000c013e  R E    0x200000
  LOAD           0x00000000000c0e40 0x00000000002c0e40 0x00000000002c0e40
                 0x00000000000053b8 0x0000000000006aa0  RW     0x200000
  DYNAMIC        0x00000000000c3c18 0x00000000002c3c18 0x00000000002c3c18
                 0x00000000000001b0 0x00000000000001b0  RW     0x8
  NOTE           0x0000000000000200 0x0000000000000200 0x0000000000000200
                 0x0000000000000044 0x0000000000000044  R      0x4
  TLS            0x00000000000c0e40 0x00000000002c0e40 0x00000000002c0e40
                 0x0000000000000020 0x0000000000000060  R      0x8
  GNU_EH_FRAME   0x00000000000b3d00 0x00000000000b3d00 0x00000000000b3d00
                 0x0000000000001afc 0x0000000000001afc  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x00000000000c0e40 0x00000000002c0e40 0x00000000002c0e40
                 0x00000000000031c0 0x00000000000031c0  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .rela.dyn .rela.plt .init .plt .plt.got .text __libc_freeres_fn __libc_thread_freeres_fn .fini .rodata .stapsdt.base .eh_frame_hdr .eh_frame .gcc_except_table
   01     .tdata .init_array .fini_array .data.rel.ro .dynamic .got .data __libc_subfreeres __libc_IO_vtables __libc_atexit __libc_thread_subfreeres .bss __libc_freeres_ptrs
   02     .dynamic
   03     .note.ABI-tag .note.gnu.build-id
   04     .tdata .tbss
   05     .eh_frame_hdr
   06
   07     .tdata .init_array .fini_array .data.rel.ro .dynamic .got
</code></pre></div><p>As an overview of the whole process, when we want to run an application on Unikraft using binary compatibility, the first step is to pass the application to the unikernel as an initial ramdisk.
Once the unikernel gets the application, the loader reads the executable segments and loads them accordingly.
After the program is loaded, the last step is to jump to its entry point and start executing.</p><p>The loader that we currently have implemented in Unikraft only supports executables that are static (so all the libraries are part of the executables) and also position-independent.
A position independent binary (PIE) is a binary that can run correctly independent of the address at which it was loaded.
So we need executables that are built using the <code>-static-pie</code> compiler / linker option, available in GCC since version 8.</p><h3 id=02-unikraft-syscall-shim>02. Unikraft Syscall Shim</h3><p>As stated previously, the system call shim layer in Unikraft is what we use in order to achieve the same system call behaviour as the Linux kernel.</p><p>Let&rsquo;s take a code snippet that does a system call from a binary:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>mov	edx,4		; message length
mov	ecx,msg		; message to write
mov	ebx,1		; file descriptor (stdout)
mov	eax,4		; system call number (sys_write)
syscall		    ; call kernel
</code></pre></div><p>In this case, when the <code>syscall</code> instruction gets executed, we have to reach the write function inside our unikernel.
In our case, when the <code>syscall</code> instruction gets called there are a few steps taken until we reach the <strong>system call</strong> inside Unikraft:</p><ol><li><p>The <code>_ukplat_syscall</code> function is the handler attached to system call instructions.
See <a href=https://github.com/unikraft/unikraft/blob/staging/plat/common/include/x86/cpu.h#L274>the source code</a>.
Whenever the <code>syscall</code> instruction is executed, control is passed to the <code>_ukplat_syscall</code> function.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>static inline void _init_syscall(void)
{
	[...]
	wrmsrl(X86_MSR_LSTAR,
        (__uptr) _ukplat_syscall);
	[...]
</code></pre></div></li><li><p>After some preparatory actions, <code>_ukplat_syscall</code> calls <code>ukplat_syscall_handler</code>.
See <a href=https://github.com/unikraft/unikraft/blob/staging/plat/common/x86/syscall.S#L38>the source code</a>.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>ENTRY(_ukplat_syscall)
	[...]
	/*
  * Handle call
  * NOTE: Handler function is going to modify saved registers state
  * NOTE: Stack pointer as &#34;struct __regs *&#34; argument
  *       (calling convention: 1st arg on %rdi)
  */
	movq %rsp, %rdi
	call ukplat_syscall_handler
	[...]
</code></pre></div><p><code>ukplat_syscall_handler</code> is also an intermediary function, printing some debug messages and passing the correct parameters further down.
The next function that gets called is the <code>uk_syscall6_r</code> function.
See <a href=https://github.com/unikraft/unikraft/blob/staging/lib/syscall_shim/uk_syscall6_r.c.in_end#L7>the source code</a>.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>void ukplat_syscall_handler(struct __regs *r)
{
	UK_ASSERT(r);

	uk_pr_debug(&#34;Binary system call request \&#34;%s\&#34; (%lu) at ip:%p (arg0=0x%lx, arg1=0x%lx, ...)\n&#34;,
         uk_syscall_name(r-&gt;rsyscall), r-&gt;rsyscall,
         (void *) r-&gt;rip, r-&gt;rarg0, r-&gt;rarg1);
	r-&gt;rret0 = uk_syscall6_r(r-&gt;rsyscall,
              r-&gt;rarg0, r-&gt;rarg1, r-&gt;rarg2,
              r-&gt;rarg3, r-&gt;rarg4, r-&gt;rarg5);
}
</code></pre></div></li><li><p>The <code>uk_syscall6_r</code> is the function that redirects the flow of the program to the actual <strong>system call</strong> function inside the kernel.
See <a href=https://github.com/unikraft/unikraft/blob/staging/lib/syscall_shim/gen_uk_syscall6_r.awk#L16>the generated source code</a>.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>switch (nr) {
	case SYS_brk:
     return uk_syscall_r_brk(arg1);
	case SYS_arch_prctl:
     return uk_syscall_r_arch_prctl(arg1, arg2, arg3);
	case SYS_exit:
     return uk_syscall_r_exit(arg1);
    ...
</code></pre></div></li></ol><p>All the above functions are generated, so the only thing that we have to do when we want to register a system call to the system call shim layer is to use the correct macros.</p><p>There are four definition macros that we can use in order to add a system call to the system call shim layer:</p><ul><li><code>UK_SYSCALL_DEFINE</code> - to implement the libc style system calls. That returns <code>-1</code> and sets the <code>errno</code> accordingly.</li><li><code>UK_SYSCALL_R_DEFINE</code> - to implement the raw variant which returns a negative error value in case of errors. <code>errno</code> is not used at all.</li></ul><p>The above two macros will generate the following functions:</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=cm>/* libc-style system call that returns -1 and sets errno on errors */</span>
<span class=kt>long</span> <span class=n>uk_syscall_e_</span><span class=o>&lt;</span><span class=n>syscall_name</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>long</span> <span class=o>&lt;</span><span class=n>arg1_name</span><span class=o>&gt;</span><span class=p>,</span> <span class=kt>long</span> <span class=o>&lt;</span><span class=n>arg2_name</span><span class=o>&gt;</span><span class=p>,</span> <span class=p>...);</span>

<span class=cm>/* Raw system call that returns negative error codes on errors */</span>
<span class=kt>long</span> <span class=n>uk_syscall_r_</span><span class=o>&lt;</span><span class=n>syscall_name</span><span class=o>&gt;</span><span class=p>(</span><span class=kt>long</span> <span class=o>&lt;</span><span class=n>arg1_name</span><span class=o>&gt;</span><span class=p>,</span> <span class=kt>long</span> <span class=o>&lt;</span><span class=n>arg2_name</span><span class=o>&gt;</span><span class=p>,</span> <span class=p>...);</span>

<span class=cm>/* libc-style wrapper (the same as uk_syscall_e_&lt;syscall_name&gt; but with actual types) */</span>
<span class=o>&lt;</span><span class=n>return_type</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=n>syscall_name</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&lt;</span><span class=n>arg1_type</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=n>arg1_name</span><span class=o>&gt;</span><span class=p>,</span>
                              <span class=o>&lt;</span><span class=n>arg2_type</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=n>arg2_name</span><span class=o>&gt;</span><span class=p>,</span> <span class=p>...);</span>
</code></pre></div><p>For the case that the libc-style wrapper does not match the signature and return type of the underlying system call, a so called low-level variant of these two macros are available: <code>UK_LLSYSCALL_DEFINE</code>, <code>UK_LLSYSCALL_R_DEFINE</code>.
These macros only generate the <code>uk_syscall_e_&lt;syscall_name></code> and <code>uk_syscall_r_&lt;syscall_name></code> symbols. You can then provide the custom libc-style wrapper on top.</p><p>Apart from using the macro to define the function, we also have to register the system call by adding it to <code>UK_PROVIDED_SYSCALLS-y</code> withing the corresponding <code>Makefile.uk</code> file.
Let&rsquo;s see how this is done with an example for the write system call.
We have the following definition of the write system call:</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=n>ssize_t</span> <span class=nf>write</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span> <span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>count</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>ssize_t</span> <span class=n>ret</span><span class=p>;</span>

    <span class=n>ret</span> <span class=o>=</span> <span class=n>vfs_do_write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>errno</span> <span class=o>=</span> <span class=n>EFAULT</span><span class=p>;</span>
        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>The next step is to define the function using the correct macro:</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=cp>#include</span> <span class=cpf>&lt;uk/syscall.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=n>UK_SYSCALL_DEFINE</span><span class=p>(</span><span class=n>ssize_t</span><span class=p>,</span> <span class=n>write</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span><span class=p>,</span> <span class=n>count</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>ssize_t</span> <span class=n>ret</span><span class=p>;</span>

    <span class=n>ret</span> <span class=o>=</span> <span class=n>vfs_do_write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>errno</span> <span class=o>=</span> <span class=n>EFAULT</span><span class=p>;</span>
        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>And the raw variant:</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C>    <span class=cp>#include</span> <span class=cpf>&lt;uk/syscall.h&gt;</span><span class=cp>
</span><span class=cp></span>
    <span class=n>UK_SYSCALL_R_DEFINE</span><span class=p>(</span><span class=n>ssize_t</span><span class=p>,</span> <span class=n>write</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span><span class=p>,</span> <span class=n>count</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>ssize_t</span> <span class=n>ret</span><span class=p>;</span>

        <span class=n>ret</span> <span class=o>=</span> <span class=n>vfs_do_write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
    <span class=p>}</span>
</code></pre></div><p>The last step is to add the system call to <code>UK_PROVIDED_SYSCALLS-y</code> in the <code>Makefile.uk</code> file.
The format is:</p><p><code>UK_PROVIDED_SYSCALLS-$(CONFIG_&lt;YOURLIB>) += &lt;syscall_name>-&lt;number_of_arguments></code></p><p>So, in our case:</p><p><code>UK_PROVIDED_SYSCALLS-$(CONFIG_LIBWRITESYS) += write-3</code></p><h2 id=summary>Summary</h2><p>The binary compatibility layer is a very important part of the Unikraft unikernel.
It helps us run applications that were not build for Unikraft while, at the same time, keeps the classic benefits of Unikraft: speed, security and small memory footprint.</p><h2 id=work-items>Work Items</h2><h3 id=support-files>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/asplos22-tutorial>in the repository</a>.
The repository is already cloned in the virtual machine.</p><p>If you want to clone the repository yourself, do</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ git clone https://github.com/unikraft/asplos22-tutorial

$ cd asplos22-tutorial/content/syscall_shim-bincompat/

$ ls -F
demo/  images/  index.md  work/
</code></pre></div><h3 id=00-setup>00. Setup</h3><p>For the practical work we will need the following prerequisites:</p><ul><li><p><strong>gcc version >= 8</strong> - installation guide <a href=https://linuxize.com/post/how-to-install-gcc-compiler-on-ubuntu-18-04/>here</a></p></li><li><p><strong>the elfloader application</strong> - this is the implementation of our loader which is build like a normal Unikraft application.
You can clone the <a href=https://github.com/skuenzer/app-elfloader/>ELF Loader repository</a>, on the <code>usoc21</code> branch.
This cloned repo should go into the <code>apps</code> folder in your Unikraft directory structure.</p></li><li><p><strong>the configuration file</strong> - you can find the <code>config</code> files in the <code>work/01/</code> and <code>work/03/</code> folders of this session.</p></li><li><p><strong>lwip, zydis, libelf libs</strong> - we have to clone all the repos coresponding to the previously mentioned libraries into the libs folder.
All of them have to be on the <code>staging</code> branch.</p><ul><li><a href=https://github.com/unikraft/lib-lwip>lwip</a></li><li><a href=https://github.com/unikraft/lib-zydis>zydis</a></li><li><a href=https://github.com/unikraft/lib-libelf>libelf</a></li></ul></li><li><p><strong>unikraft</strong> - the <a href=https://github.com/unikraft/unikraft>Unikraft repository</a> must also be cloned and checked out on the <code>usoc21</code> branch.</p></li></ul><p>These repositories are already cloned in the virtual machine, in the <code>~/syscall_shim-bincompat/</code> folder.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>syscall_shim-bincompat/
`-- apps/
|   `-- app-elfloader/ [usoc21]
`-- libs/
|   |-- libelf/ [staging]
|   |-- lwip/ [staging]
|   `-- zydis/ [staging]
`-- unikraft/ [usoc21]
</code></pre></div><h3 id=01-compiling-the-elf-loader-application>01. Compiling the ELF Loader Application</h3><p>The goal of this task is to make sure that our setup is correct.
The first step is to copy the correct <code>.config</code> file into our application.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cp ~/asplos22-tutorial/content/syscall_shim-bincompat/work/01/config ~/syscall_shim-bincompat/apps/app-elfloader/.config
</code></pre></div><p>To check that the config file is the correct one, go to the <code>app-elfloader/</code> directory and configure it:</p><ol><li><p>Change the directory to <code>~/syscall_shim-bincompat/apps/app-elfloader/</code>.</p></li><li><p>Check the configuration:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>make menuconfig
</code></pre></div></li><li><p>Select <code>Library Configuration</code>.
It should look like the below picture.
Take a moment and inspect all the sub-menus, especially the syscall-shim one.</p><p><img src=images/config-image.png alt="Libraries configuration"></p></li></ol><p>If everything seems correct, build the unikernel loader image:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make
</code></pre></div><p>In the <code>build/</code> folder you should have the <code>elfloader_kvm-x86_64</code> binary.
To also test if it runs correctly, copy the <code>qemu-guest</code> script from the <code>a-look-inside/</code> session:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cp ~/asplos22-tutorial/content/a-look-inside/work/02-adding-filesystems/qemu-guest ~/syscall_shim-bincompat/apps/app-elfloader/
</code></pre></div><p>And use <code>qemu-guest</code> to run the ELF loader image:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>.../apps/app-elfloader$ ./qemu-guest -k build/elfloader_kvm-x86_64

SeaBIOS (version 1.10.2-1ubuntu1)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                  Tethys 0.5.0~825b1150
[    0.105192] ERR:  &lt;0x3f20000&gt; [appelfloader] No image found (initrd parameter missing?)
</code></pre></div><p>Because we did not pass an initial ramdisk, the loader does not have anything to load and prints the above error.</p><h3 id=02-compile-a-static-pie-executable-and-run-it-on-top-of-unikraft>02. Compile a Static-Pie Executable and Run It On Top of Unikraft</h3><p>The next step is to get an executable with the correct format.
We require a static executable that is also PIE (<em>Position-Independent Executable</em>).</p><p>We go to the <code>apps/app-elfloader/example/helloworld</code> directory.
We can see that the directory has a <code>helloworld.c</code> (a simple helloworld program) and a <code>Makefile</code>.
The program will be compiled as a static PIE:</p><div class=highlight><pre class=chroma><code class=language-Makefile data-lang=Makefile><span class=nv>RM</span> <span class=o>=</span> rm -f
<span class=nv>CC</span> <span class=o>=</span> gcc
<span class=nv>CFLAGS</span> <span class=o>+=</span> -O2 -g -fpie <span class=c1># fpie generates position independet code in the object file</span>
<span class=nv>LDFLAGS</span> <span class=o>+=</span> -static-pie <span class=c1># static-pie makes the final linking generate a static and a pie executable</span>
<span class=nv>LDLIBS</span> <span class=o>+=</span>

<span class=nf>all</span><span class=o>:</span> <span class=n>helloworld</span>

<span class=nf>%.o</span><span class=o>:</span> %.<span class=n>c</span>
	<span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -c $&lt; -o <span class=nv>$@</span>

<span class=nf>%</span><span class=o>:</span> %.<span class=n>o</span>
	<span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>LDFLAGS<span class=k>)</span> $^ <span class=k>$(</span>LDLIBS<span class=k>)</span> -o <span class=nv>$@</span>

<span class=nf>helloworld</span><span class=o>:</span> <span class=n>helloworld</span>.<span class=n>o</span>

<span class=nf>clean</span><span class=o>:</span>
	<span class=k>$(</span>RM<span class=k>)</span> *.o *~ core helloworld
</code></pre></div><p>We can now run <code>make</code> so we can get the <code>helloworld</code> executable:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>.../apps/app-elfloader/example/helloworld$ make
gcc -O2 -g -fpie -c helloworld.c -o helloworld.o
gcc -static-pie helloworld.o  -o helloworld

.../apps/app-elfloader/example/helloworld$ ldd helloworld
	statically linked

.../apps/app-elfloader/example/helloworld$ checksec --file=helloworld
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre></div><p>We can see above from the <code>ldd</code> and <code>checksec</code> output that the <code>helloworld</code> executable is a static PIE.</p><p>Now, the last part is to pass this executable to our unikernel.
We can use the <code>-i</code> option to pass the initial ramdisk to the virtual machine.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>.../apps/app-elfloader$ qemu-guest -k build/elfloader_kvm-x86_64 -i example/helloworld/helloworld

SeaBIOS (version 1.10.2-1ubuntu1)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                  Tethys 0.5.0~825b1150
Hello world!
</code></pre></div><p>The binary is successfully loaded and executed.</p><h3 id=03-diving-deeper>03. Diving Deeper</h3><p>Now that we saw how we can run an executable on top of Unikraft through binary compatibility, let&rsquo;s take a look at what happens behind the scenes.
For this we have to compile the unikernel with debug printing.</p><p>Copy the <code>config_debug</code> file to our application folder:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cp ~/asplos22-tutorial/content/syscall_shim-bincompat/work/03/config_debug ~/syscall_shim-bincompat/apps/app-elfloader/.config
</code></pre></div><p>Now, recompile the unikernel:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>.../apps/app-elfloader$ make properclean
[...]
.../apps/app-elfloader$ make
</code></pre></div><p>Now, let&rsquo;s rerun the previously compiled executable on top of Unikraft:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>.../apps/app-elfloader$ qemu-guest -k build/elfloader_kvm-x86_64 -i example/helloworld/helloworld

SeaBIOS (version 1.10.2-1ubuntu1)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                  Tethys 0.5.0~825b1150
[    0.153848] dbg:  &lt;0x3f20000&gt; [libukboot] Call constructor: 0x10b810()...
[    0.156271] dbg:  &lt;0x3f20000&gt; [appelfloader] Searching for image...
[    0.159115] dbg:  &lt;0x3f20000&gt; [appelfloader] Load image...
[    0.161569] dbg:  &lt;0x3f20000&gt; [appelfloader] build/elfloader_kvm-x86_64: ELF machine type: 62
[    0.164844] dbg:  &lt;0x3f20000&gt; [appelfloader] build/elfloader_kvm-x86_64: ELF OS ABI: 3
[    0.167843] dbg:  &lt;0x3f20000&gt; [appelfloader] build/elfloader_kvm-x86_64: ELF object type: 3
[...]
</code></pre></div><p>We now have a more detailed output to see exactly what happens.
The debug output is divided as follows:</p><ol><li>Debug information that comes from when the unikernel is executing.</li><li>Debug information that comes from when the binary is executing.</li></ol><p>When the unikernel is executing (so our loader application) there are two phases:</p><ol><li><p>The <em>loading phase</em>: copies the contents of the binary at certain memory zones, as specified by the ELF header.
You can see the loading phase in the debug output:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>[appelfloader] Load image...
[...]
[appelfloader] build/elfloader_kvm-x86_64: Program/Library memory region: 0x3801000-0x3ac88e0 &lt;- this is the memory zone where our binary will be mapped
[appelfloader] build/elfloader_kvm-x86_64: Copying 0x171000 - 0x23113e -&gt; 0x3801000 - 0x38c113e &lt;- actual copying of the binary
[appelfloader] build/elfloader_kvm-x86_64: Zeroing 0x38c113e - 0x38c113e &lt;- zeroing out zones of the binary, like the bss
[...]
</code></pre></div></li><li><p>The <em>execution phase</em>: sets the correct information on the stack (for example environment variables) and jumps to the program entry point.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>[appelfloader] Execute image...
[appelfloader] build/elfloader_kvm-x86_64: image:          0x3801000 - 0x3ac88e0
[appelfloader] build/elfloader_kvm-x86_64: start:          0x3801000
[appelfloader] build/elfloader_kvm-x86_64: entry:          0x3809940
[appelfloader] build/elfloader_kvm-x86_64: ehdr_phoff:     0x40
[appelfloader] build/elfloader_kvm-x86_64: ehdr_phnum:     8
[appelfloader] build/elfloader_kvm-x86_64: ehdr_phentsize: 0x38
[appelfloader] build/elfloader_kvm-x86_64: rnd16 at 0x3f1ff20
[appelfloader] Jump to program entry point at 0x3809940...
</code></pre></div></li></ol><p>From this point forward, the binary that we passed in the initial ramdisk starts executing.
Now all the debug messages come from an operation that happened in the binary.
We can also now see the syscall shim layer in action:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>[libsyscall_shim] Binary system call request &#34;write&#34; (1) at ip:0x3851c21 (arg0=0x1, arg1=0x3c01640, ...)
Hello world!
</code></pre></div><p>In the above case, the binary used a <code>write</code> system call in order to write <em>Hello world!</em> to standard output.</p><h3 id=04-solve-the-missing-syscall>04. Solve the Missing Syscall</h3><p>Let&rsquo;s try to run another binary on top of Unikraft.
You can find the C program in the <code>04-missing-syscall/</code> directory.
Try compiling it as static-pie and then run it on top of Unikraft.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>[libsyscall_shim] Binary system call request &#34;getcpu&#34; (309) at ip:0x3851926 (arg0=0x3f1fc14, arg1=0x0, ...)
[libsyscall_shim] syscall &#34;getcpu&#34; is not available
[libsyscall_shim] Binary system call request &#34;write&#34; (1) at ip:0x3851cb1 (arg0=0x1, arg1=0x3c01640, ...)
Here we are in the binary, calling getcpu
Getcpu returned: -1
</code></pre></div><p>Your task is to print a debug message betweem the <code>Here we are in the binary</code> and <code>Getcpu returned</code> message above and also make the <code>sched_getcpu()</code> return 0.</p><p><strong>Hint 1</strong>: <a href=http://docs.unikraft.org/developers-app.html#syscall-shim-layer>Syscall Shim Layer</a></p><p><strong>Hint 2</strong>: Check the <code>brk.c</code>, <code>Makefile.uk</code> and <code>exportsyms.uk</code> files in the <code>app-elfloader</code> directory.
You do not have to use <code>UK_LLSYSCALL_R_DEFINE</code>, instead, use the two other macros previously described in the session (eg. <code>UK_SYSCALL_DEFINE</code> and <code>UK_SYSCALL_R_DEFINE</code>).</p><h3 id=05-load-the-binary-from-the-filesystem>05. Load the Binary from the Filesystem</h3><p>Up until now, we passed the binary as an initial ramdisk image.
We aimt to pass it as a file in a mounted filesytem.</p><p>Create a folder, copy executable files in that folder and mount it using 9pfs support.
The open the file in <code>main.c</code> annd load it.</p><p><strong>Hint</strong>: Check the filesystem work items in the <a href=../a-look-inside/>&ldquo;Inside the config and build system&rdquo; session</a>.</p><h2 id=further-reading>Further Reading</h2><p><a href=https://dtrugman.medium.com/elf-loaders-libraries-and-executables-on-linux-e5cfce318f94>Elf Loaders, Libraries and Executables on Linux</a></p></div></div></div></div></div></div><footer class=sub-footer><div class="container py-5"><div class=row><div class="col-12 col-md">Unikraft
<small class="d-block mb-3 text-muted">© 2021</small></div><div class="col-6 col-md"><h5>Social</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://twitter.com/UnikraftSDK>Twitter</a></li><li><a class=text-muted href=https://www.linkedin.com/company/unikraft-sdk/>LinkedIn</a></li></ul></div><div class="col-6 col-md"><h5>&nbsp;</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://bit.ly/UnikraftDiscord>Discord</a></li><li><a class=text-muted href=https://github.com/unikraft/unikraft>GitHub</a></li></ul></div><div class="col-6 col-md"><h5>Resources</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://unikraft.org>Unikraft Homepage</a></li><li><a class=text-muted href=https://unikraft.io>Unikraft Cloud</a></li></ul></div><div class="col-6 col-md"><h5>&nbsp;</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=http://docs.unikraft.org>Documentation</a></li><li><a class=text-muted href=https://unikraft.org/license/>Open-Source Licenses</a></li></ul></div></div></footer></div><script type=text/javascript src=/js/scripts.min.eaf147370baecdd07c022597db631f99cab1c9cd6479de586f30327a568d6a0f.js></script></body></html>