<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>Getting started with Unikraft - ASPLOS'22 Tutorial</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Unikraft ASPLOS'22 Tutorial"><meta property="og:title" content="Unikraft ASPLOS'22 Tutorial"><meta property="og:type" content="website"><meta property="og:url" content="https://asplos22.unikraft.org"><meta property="og:description" content="ASPLOS'22 Tutorial on Unikraft: educating the community on unikernels, libOSes, and particularly Unikraft."><meta name=twitter:card content="summary"><meta name=twitter:site content="@UnikraftSDK"><meta name=twitter:creator content="@UnikraftSDK"><link rel=icon href=/favicon.png><link rel=stylesheet href=/css/style.min.9d91cadd6bf9a027131051416b1155705f1a4ce3735fcdef7072384726bf9590.css></head><body class="page page-default-single"><div id=main-menu-mobile class=main-menu-mobile><ul><li class="menu-item-learn more about unikraft"><a href=https://unikraft.org><span>Learn more about Unikraft</span></a></li></ul></div><div class=wrapper><div class=header><div class=container><div class=logo><a href=/><img alt=Logo src=/images/unikraft.svg>
<span>ASPLOS'22 Tutorial</span></a></div><div class=logo-mobile><a href=/><img alt=Logo src=/images/unikraft.svg>
<span>ASPLOS'22 Tutorial</span></a></div><div id=main-menu class=main-menu><ul><li class="menu-item-learn more about unikraft"><a href=https://unikraft.org><span>Learn more about Unikraft</span></a></li></ul></div><button id=toggle-main-menu-mobile class="hamburger hamburger--slider" type=button>
<span class=hamburger-box><span class=hamburger-inner></span></span></button></div></div><div class="container pt-2 pt-md-4 pb-3 pb-md-6"><div class=row><div class="col-12 col-md-3 mb-3"><div class=sidebar><div class=docs-menu><h4></h4><ul><li><a href=/intro/>Introduction to Unikraft</a></li><li class=active><a href=/getting-started/>Getting started with Unikraft</a></li><li><a href=/a-look-inside/>Inside the Config and Build System</a></li><li><a href=/complex-apps/>Running complex applications</a></li><li><a href=/syscall_shim-bincompat/>Syscall Shim and Binary Compatibility Layer</a></li><li><a href=/high-performance/>High performance applications</a></li><li><a href=/current-research-and-dev/>Unikernels: Paths to Production & Current Research Trends</a></li><li><a href=/people/>People</a></li></ul></div></div></div><div class="col-12 col-md-9"><h1 class=title>Getting started with Unikraft</h1><div class=content><p><em>The presentation of this session can be found <a href=/asplos22-intro-alexander-jung.pdf>here</a>.</em></p><p>In this session we are going to understand the basic layout of the Unikraft working directory, its environment variables, as well as what the most common Unikraft specific files mean.
We are also going to take a look at how we can build basic applications and how we can extend their functionality and support by adding ported external libraries.</p><p>Before everything, let&rsquo;s take a bird&rsquo;s eye view of what Unikraft is and what we can do with it.
Unikraft is a unikernel SDK, meaning it offers you the blocks (source code, configuration and build system, runtime support) to build and run unikernels.
A unikernel is a single image file that can be loaded and run as a separate running instance, most often a virtual machine.</p><p>Summarily, Unikraft components are shown in the image below:</p><p><img src=/getting-started/images/unikraft_components.png alt="arch selection menu"></p><p>Unikraft is the core component, consisting of core / internal libraries, the build system, and platform and architecture code.
It is the basis of any unikernel image.
It is located in the <a href=https://github.com/unikraft/unikraft>main Unikraft repository</a>.</p><p>Libraries are additional software components that will be linked with Unikraft for the final image.
There are multiple supported libraries.
Each unikernel image is using its specific libraries.
Libraries are also called <strong>external</strong> libraries as they sit outside the main Unikraft repository.
Libraries are typically common libraries (such as OpenSSL or LWIP) that have been ported on top of Unikraft.
They are located in specialized repositories in the <a href=https://github.com/unikraft/>Unikraft organization</a>, those whose names start with <code>lib-</code>.</p><p>Application is the actual application code.
It typically provides the <code>main()</code> function (or equivalent) and is reliant on Unikraft and external libraries.
Applications that have been ported on top of Unikraft are located in repositories in the <a href=https://github.com/unikraft/>Unikraft organization</a>, those whose names start with <code>app-</code>.</p><p>An important role of the core Unikraft component is providing support for different platforms and architectures.
A platform is the virtualization / runtime environment used to run the resulting unikernel image.
An architecture details the CPU and memory specifics that will run the resulting image.</p><p>As this is a rather complicated setup, a companion tool (<a href=https://github.com/unikraft/kraft>kraft</a>) was designed and implemented to provide the interface for configuring, building and running unikernel images based on Unikraft.
The recommended way of building and running Unikraft is via <code>kraft</code>.</p><p>We are going to build the <a href=https://github.com/unikraft/app-helloworld>helloworld</a> application and the <a href=https://github.com/unikraft/app-httpreply>httpreply</a> application using <code>kraft</code>.
We are also going to use the lower-level configuration and build system (based on <a href=https://www.kernel.org/doc/html/latest/kbuild/kconfig-language.html>Kconfig</a> and Makefile) to get a grasp of how everything works.
The lower-level system will be detailed further in session 02: Behind the Scenes.</p><h2 id=demos>Demos</h2><h3 id=00-manual-kraft-installation>00. Manual kraft Installation</h3><p>Let&rsquo;s start with installing kraft (and validating the installation).</p><p>First of all, make sure you have all the dependencies installed:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo apt-get install -y --no-install-recommends build-essential \
        libncurses-dev libyaml-dev flex git wget socat bison \
        unzip uuid-runtime
</code></pre></div><p>We begin by cloning the kraft repository on our machine:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>git clone https://github.com/unikraft/kraft.git
</code></pre></div><p>Now, all we have to do is enter this directory and run the setup installer:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd kraft
$ pip install --user -e .
</code></pre></div><p>This will install kraft for the local user.</p><p>After installing or updating kraft, the first step is to download / update the software components available for building unikernel images.
For this, run:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft list update
</code></pre></div><p>It&rsquo;s very likely that running the command above will result in the following error:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>GitHub rate limit exceeded.  You can tell kraft to use a personal access token by setting the UK_KRAFT_GITHUB_TOKEN environmental variable.
</code></pre></div><p>If this is the case, first create a GitHub personal access token by following <a href=https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token>these instructions</a>.
Then, use the following command:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ UK_KRAFT_GITHUB_TOKEN=&lt;your_GitHub_token_here&gt; kraft list update
</code></pre></div><p>After this is done, you can get a list of all components that are available for use with kraft:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft list
UNIKRAFT        	VERSION 	RELEASED    	LAST CHECKED
unikraft        	0.5     	17 hours ago	18 Aug 21

PLATFORMS       	VERSION 	RELEASED    	LAST CHECKED
solo5           	0.5     	13 Jul 21   	18 Aug 21
[...]

LIBRARIES       	VERSION 	RELEASED    	LAST CHECKED
newlib          	0.5     	5 days ago  	18 Aug 21
pthreadpool     	0.5     	7 days ago  	18 Aug 21
lwip            	0.5     	6 days ago  	18 Aug 21
[...]

APPLICATIONS    	VERSION 	RELEASED    	LAST CHECKED
python3         	0.4     	29 Mar 21   	18 Aug 21
helloworld      	0.5     	29 Mar 21   	18 Aug 21
httpreply       	0.5     	13 Jul 21   	18 Aug 21
[...]
</code></pre></div><p>So, with kraft we have an interface to configure, build and run unikernel images based on Unikraft core, (external) platforms, (external) libraries and applications.</p><p>By default, these are saved to <code>~/.unikraft/</code> directory, which is also the value of the <code>UK_WORKDIR</code> environment variable used by kraft.
This represents the working directory for all Unikraft components.
This is the usual layout of the <code>~/.unikraft/</code> directory:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>|-- apps - This is where you would normally place existing app build
|-- archs - Here we place our custom arch&#39;s files
|-- libs - This is where the build system looks for external library pool sources
|-- plats - The files for our custom plats are placed here
`-- unikraft - The core source code of the Unikraft Unikernel
</code></pre></div><p>Apart from the general <code>UK_WORKDIR</code> environment variable that points to the overall directory, there are also environment variables available for the above subdirectories:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>UK_ROOT - The directory for Unikraft&#39;s core source code [default: $UK_WORKDIR/unikraft]
UK_LIBS - The directory of all the external Unikraft libraries [default: $UK_WORKDIR/libs]
UK_APPS - The directory of all the template applications [default: $UK_WORKDIR/apps]
</code></pre></div><p>After successfully running the above commands, kraft is now installed on our system and we can get to building and running unikernels.</p><h3 id=01-building-and-running-the-helloworld-application>01. Building and Running the Helloworld Application</h3><p>This is where the fun part begins - we get to build our first unikernel.</p><h4 id=one-command-to-rule-them-all>One Command to Rule Them All</h4><p>kraft makes it easy to download, configure, build existing components into unikernel images and then run those images.
The <code>kraft up</code> command makes it easy to do that with one swoop.
Let&rsquo;s do that for the <code>helloworld</code> application (listed with <code>kraft list</code>):</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft up -t helloworld hello
 100.00% :::::::::::::::::::::::::::::::::::::::: |       21 /       21 |:  app/helloworld@0.5
[INFO    ] Initialized new unikraft application: /home/razvan/hello
make: Entering directory &#39;/home/razvan/.unikraft/unikraft&#39;
[...]
#
# configuration written to /home/razvan/hello/.config
#
[...]
CC      libkvmplat: trace.common.o
CC      libkvmplat: traps.isr.o
CC      libkvmplat: cpu_features.common.o
[...]
CC      libnolibc: errno.o
CC      libnolibc: stdio.o
CC      libnolibc: ctype.o
[...]
LD      hello_kvm-x86_64.ld.o
OBJCOPY hello_kvm-x86_64.o
LD      hello_kvm-x86_64.dbg
SCSTRIP hello_kvm-x86_64
GZ      hello_kvm-x86_64.gz
LN      hello_kvm-x86_64.dbg.gdb.py
[...]
Successfully built unikernels:

  =&gt; build/hello_kvm-x86_64
  =&gt; build/hello_kvm-x86_64.dbg (with symbols)

[...]
To instantiate, use: kraft run
[...]
Starting VM...
[...]
                   Tethys 0.5.0~b8be82b
Hello world!
Arguments:  &#34;/home/razvan/hello/build/hello_kvm-x86_64&#34; &#34;console=ttyS0&#34;
</code></pre></div><p>In the snippet above, we selected parts of the output showing what <code>kraft</code> does behind the scenes:</p><ol><li>It downloads the <code>helloworld</code> application repository in the <code>hello/</code> directory.</li><li>It configures the repository, resulting in a <code>.config</code> file.</li><li>It builds the required components, resulting in the <code>build/hello_kvm-x86_64</code> unikernel image.</li><li>It runs the image, resulting in QEMU/KVM being run, with the &ldquo;Hello world!&rdquo; message getting printed.</li></ol><p>All that magic is done using one command.</p><p>A closer inspection of the <code>hello/</code> folder reveals it is a clone of the <a href=https://github.com/unikraft/app-helloworld>app-helloworld repository</a> and it stores the resulting configuration file (<code>.config</code>) and resulting build folder (and images) (<code>build/</code>):</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ls -Fa hello/
./  ../  build/  CODING_STYLE.md  .config  Config.uk  CONTRIBUTING.md  COPYING.md  .git/  kraft.yaml  main.c  MAINTAINERS.md  Makefile  Makefile.uk  monkey.h  README.md
</code></pre></div><p>Once this is done, we can now run the resulting unikernel image any time we want by simply using <code>kraft run</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd hello/
$ kraft run
[...]
                   Tethys 0.5.0~b8be82b
Hello world!
Arguments:  &#34;/home/razvan/hello/build/hello_kvm-x86_64&#34; &#34;console=ttyS0&#34;
</code></pre></div><h4 id=doing-it-step-by-step-using-kraft>Doing it Step-by-Step Using kraft</h4><p>The above <code>kraft up</code> command seems like magic and it&rsquo;s not very clear what&rsquo;s really happening.
Let&rsquo;s break that down into subcommands and really get a good grip of the configure, build and run process.</p><p>We will go through the same steps above, running a separate command for each step:</p><ol><li>Download / Initialize the helloworld appplication.</li><li>Configure the application, resulting in a <code>.config</code> file.</li><li>Build the required components, resulting in the <code>build/hello_kvm-x86_64</code> unikernel image.</li><li>Run the image, with the &ldquo;Hello world!&rdquo; message getting printed.</li></ol><h5 id=initialize>Initialize</h5><p>First, let&rsquo;s create a directory that will host the application.
We enter the <code>demo/</code> directory of the current session and we create the <code>01-hello-world/</code> directory:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd demo/
$ mkdir 01-hello-world
$ cd 01-hello-world/
</code></pre></div><p>Now, we initialize the application by using the template for the helloworld app and see that it&rsquo;s populated with files belonging to the app:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft init -t helloworld
$ ls
CODING_STYLE.md  Config.uk  CONTRIBUTING.md  COPYING.md  kraft.yaml  main.c  MAINTAINERS.md  Makefile  Makefile.uk  monkey.h  README.md
</code></pre></div><p>The <code>kraft.yaml</code> file is the most important file.
It stores kraft-speficic configuration for the app and it&rsquo;s used by kraft when configuring, building and running the application.
Other files are important as well, but they are used behind the scenes by kraft.
We will detail them later in the session and in session 02: Behind the Scenes.</p><h5 id=configure>Configure</h5><p>A unikernel image may be targeted for multiple platforms and architectures.
The available platforms and applications are listed in the <code>kraft.yaml</code> file:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cat kraft.yaml
specification: &#39;0.4&#39;

unikraft: &#39;0.5&#39;

architectures:
  x86_64: true
  arm64: true

platforms:
  linuxu: true
  kvm: true
  xen: true
</code></pre></div><p>In our case, we can target the <code>x86_64</code> or <code>arm64</code> architectures.
And we can target <code>linuxu</code>, <code>kvm</code> or <code>xen</code> platforms.</p><p>The simplest way to select the platform and architecture is by running <code>kraft configure</code> and then interactively use arrow keys to select the desired option:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft configure
[?] Which target would you like to configure?: 01-hello-world_linuxu-x86_64
 &gt; 01-hello-world_linuxu-x86_64
   01-hello-world_kvm-x86_64
   01-hello-world_xen-x86_64
   01-hello-world_linuxu-arm64
   01-hello-world_kvm-arm64
   01-hello-world_xen-arm64
</code></pre></div><p>We have 6 options (2 architectures x 3 platforms).
Once we select one, the configuration will be updated.</p><p>The alternate way (non-interactive) is to pass arguments to <code>kraft configure</code> to select the desired platform and architecture.
For example, if we want to use x86_64 and KVM, we use:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft configure -p kvm -m x86_64
</code></pre></div><h5 id=build>Build</h5><p>Everything is set up now, all we have left to do is tell the build system to do its magic:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft build
[...]
Successfully built unikernels:

  =&gt; build/01-hello-world_kvm-x86_64
  =&gt; build/01-hello-world_kvm-x86_64.dbg (with symbols)

To instantiate, use: kraft run
</code></pre></div><p>This results in the creation of two unikernel image files:</p><ol><li><code>build/01-hello-world_kvm-x86_64</code> - the main image file</li><li><code>build/01-hello-world_kvm-x86_64.dbg</code> - the image file with debug information (useful for debugging, duh!)</li></ol><p>And that&rsquo;s it! Our final unikernel binary is ready to be launched from the <code>build/</code> directory.</p><h5 id=run>Run</h5><p>To run an already-built unikernel image, we use <code>kraft run</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft run
[...]

                   Tethys 0.5.0~b8be82b
Hello world!
[...]
</code></pre></div><p>If we want to be more specific, we could use:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft run -p kvm -m x86_64
</code></pre></div><p>This command is useful in the case we have multiple images built (for differing platforms and architectures).
We can then select which one to run.</p><p>For example, we can use the commands below to configure, build and run a helloworld image for the <code>linuxu</code> platform.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>kraft configure -p linuxu -m x86_64
kraft build
kraft run -p linuxu -m x86_64
</code></pre></div><p>You can now alter between running the <code>linuxu</code> and the <code>kvm</code> built images by using <code>kraft run</code> with the appropriate arguments.</p><h4 id=more-on-kraft>More on kraft</h4><p>Of course, this is the most basic way you can use <code>kraft</code>, but there are many other options.
To see every option <code>kraft</code> has to offer, you can simply type <code>kraft -h</code>.
If you want to know about a certain command, just follow it with the <code>-h</code> option.
For example, if I wanted to know more about the configure command, I would type <code>kraft configure -h</code>.</p><h4 id=manually-building-the-helloworld-application>Manually Building the helloworld Application</h4><p>Let&rsquo;s now learn how to build the app manually, without <code>kraft</code>.
We won&rsquo;t go into too much detail, this will be handled more thoroughly in session 02: Behind the Scenes.</p><p>The manual approach is more complicated (albeit giving you potentially more control) than kraft.
For most of the use cases (development, testing, evaluating, using) of Unikraft, we recommend you use kraft.</p><p>We will go through the same steps as above:</p><ol><li>Download / Initialize the helloworld application.</li><li>Configure the application, resulting in a <code>.config</code> file.</li><li>Build the required components, resulting in the <code>build/hello_kvm-x86_64</code> unikernel image.</li><li>Run the image, with the &ldquo;Hello world!&rdquo; message getting printed.</li></ol><h5 id=initialize-1>Initialize</h5><p>First, get out of the current build&rsquo;s directory and make a new one:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd ../ &amp;&amp; mkdir 01-hello-world-manual &amp;&amp; cd 01-hello-world-manual
</code></pre></div><p>Now, clone the remote Git repository:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ git clone https://github.com/unikraft/app-helloworld.git .
$ ls
CODING_STYLE.md  Config.uk  CONTRIBUTING.md  COPYING.md  kraft.yaml  main.c  MAINTAINERS.md  Makefile  Makefile.uk  monkey.h  README.md
</code></pre></div><h5 id=configure-1>Configure</h5><p>To configure the build process (and the resulting unikernel image) we access a text-user interface menu by using:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div><p>Looks like we are met with an error:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
Makefile:9: recipe for target &#39;menuconfig&#39; failed
make: *** [menuconfig] Error 2
</code></pre></div><p>We look in the <code>Makefile</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cat -n Makefile
     1  UK_ROOT ?= $(PWD)/../../unikraft
     2  UK_LIBS ?= $(PWD)/../../libs
     3  LIBS :=
     4
     5  all:
     6          @$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)
     7
     8  $(MAKECMDGOALS):
     9          @$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre></div><p>The underlying build / configuration system expects the Unikernel (<code>UK_ROOT</code>) to be located at <code>../../unikraft</code> from the current directory, which is very likely not the case.
Recall that the build system makes use of some important environment variables, namely <code>UK_WORKDIR</code>, <code>UK_ROOT</code> and <code>UK_LIBS</code>.
So, in order to properly inform the build system of our current location, we will have to manually set these by prefixing whatever build command we send with the hardcoded values of where our <code>Unikraft</code> work directory is.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ UK_WORKDIR=~/.unikraft UK_ROOT=~/.unikraft/unikraft UK_LIBS=~/.unikraft/libs make menuconfig
</code></pre></div><p><strong>Note</strong>: This menu is also available through the <code>kraft menuconfig</code> command, which rids you of the hassle of manually setting the environment variables.</p><p>We are met with the following configuration menu. Let&rsquo;s pick the architecture:</p><p><img src=/getting-started/images/menuconfig_select_arch.png alt="arch selection menu"></p><p><img src=/getting-started/images/menuconfig_select_arch2.png alt="arch selection menu2"></p><p><img src=/getting-started/images/menuconfig_select_arch3.png alt="arch selection menu3"></p><p>Now, press <code>Exit</code> (or hit the <code>Esc</code> key twice) until you return to the initial menu.</p><p>We have now set our desired architecture, let&rsquo;s now proceed with the platform.
We will choose both <code>linuxu</code> and <code>kvm</code>:</p><p><img src=/getting-started/images/menuconfig_select_plat.png alt="plat selection menu"></p><p><img src=/getting-started/images/menuconfig_select_plat2.png alt="plat selection menu2"></p><p><code>Save</code> and exit the configuration menu by repeatedly selecting <code>Exit</code>.</p><h5 id=build-1>Build</h5><p>Now let&rsquo;s build the final image (recall the environment variables):</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ UK_WORKDIR=~/.unikraft UK_ROOT=~/.unikraft/unikraft UK_LIBS=~/.unikraft/libs  make
[...]
  LD      01-hello-world-manual_linuxu-x86_64.dbg
  SCSTRIP 01-hello-world-manual_kvm-x86_64
  GZ      01-hello-world-manual_kvm-x86_64.gz
  SCSTRIP 01-hello-world-manual_linuxu-x86_64
  LN      01-hello-world-manual_kvm-x86_64.dbg.gdb.py
  LN      01-hello-world-manual_linuxu-x86_64.dbg.gdb.py
</code></pre></div><p>Our final binaries are located inside the <code>build/</code> directory.</p><h5 id=run-1>Run</h5><p>Let&rsquo;s run the <code>linuxu</code> image by doing a Linux-like executable running:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ./build/01-hello-world-manual_linuxu-x86_64  # The linuxu image
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Hello world!
</code></pre></div><p>To run the KVM image, we use the <code>qemu-system-x86_64</code> command:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ qemu-system-x86_64 -kernel build/01-hello-world-manual_kvm-x86_64 -nographic
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Hello world!
Arguments:  &#34;build/hello_kvm-x86_64&#34;
</code></pre></div><h3 id=02-building-and-running-the-httpreply-application>02. Building and Running the httpreply Application</h3><p>This is where we will take a look at how to build a basic HTTP Server both through <code>kraft</code> and manually.
The latter involves understanding how to integrate ported external libraries, such as <code>lwip</code>.</p><h4 id=using-kraft>Using kraft</h4><p>Just as before, let&rsquo;s create a directory that will host the application.
We enter the <code>demo/</code> directory of the current session and we create the <code>01-hello-world/</code> directory:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd demo/
$ mkdir 02-httpreply
$ cd 02-httpreply/
</code></pre></div><p>Now, we go through the steps above.</p><h5 id=initialize-2>Initialize</h5><p>Retrieve the already existing template for <code>httpreply</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft init -t httpreply
</code></pre></div><h5 id=configure-2>Configure</h5><p>Configure the building of a KVM unikernel image for x86_64:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft configure -p kvm -m x86_64
</code></pre></div><h5 id=build-2>Build</h5><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft build
</code></pre></div><h5 id=run-2>Run</h5><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft run -p kvm -m x86_64
[...]
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Listening on port 8123...
</code></pre></div><p>Use <code>Ctrl+c</code> to stop the HTTP server running as a unikernel virtual machine.</p><h5 id=connecting-to-the-http-server>Connecting to the HTTP Server</h5><p>The server listens on port <code>8123</code> but we can&rsquo;t access it, as the virtual machine doesn&rsquo;t have a (virtual) network connection to the host system and it doesn&rsquo;t have an IP address.
So we have to create a connection and assign an IP address.</p><p>We use a virtual bridge to create a connection between the VM and the host system.
We assign address <code>172.44.0.1/24</code> to the bridge interface (pointing to the host) and we assign address <code>172.44.0.2/24</code> to the virtual machine, by passing boot arguments.</p><p>We run the commands below to create and assign the IP address to the bridge <code>virbr0</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo brctl addbr virbr0
$ sudo ip a a  172.44.0.1/24 dev virbr0
$ sudo ip l set dev virbr0 up
</code></pre></div><p>We can check the proper configuration:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ip a s virbr0
420: virbr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000
    link/ether 3a:3e:88:e6:a1:e4 brd ff:ff:ff:ff:ff:ff
    inet 172.44.0.1/24 scope global virbr0
       valid_lft forever preferred_lft forever
    inet6 fe80::383e:88ff:fee6:a1e4/64 scope link
       valid_lft forever preferred_lft forever
</code></pre></div><p>Now we start the virtual machine and pass it the proper arguments to assign the IP address <code>172.44.0.2/24</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ kraft run -b virbr0 &#34;netdev.ipv4_addr=172.44.0.2 netdev.ipv4_gw_addr=172.44.0.1 netdev.ipv4_subnet_mask=255.255.255.0 --&#34;
[...]
0: Set IPv4 address 172.44.0.2 mask 255.255.255.0 gw 172.44.0.1
en0: Added
en0: Interface is up
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Listening on port 8123...
</code></pre></div><p>The boot message confirms the assigning of the <code>172.44.0.2/24</code> IP address to the virtual machine.
It&rsquo;s listening on port 8123 for HTTP connections on that IP address.
We use <code>wget</code> to validate it&rsquo;s working properly and we are able to get the <code>index.html</code> file:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ wget 172.44.0.2:8123
--2021-08-18 16:47:38--  http://172.44.0.2:8123/
Connecting to 172.44.0.2:8123... connected.
HTTP request sent, awaiting response... 200 OK
[...]
2021-08-18 16:47:38 (41.5 MB/s) - ‘index.html’ saved [160]
</code></pre></div><p>Cleaning up means closing the virtual machine (and the HTTP server) and disabling and deleting the bridge interface:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo ip l set dev virbr0 down
$ sudo brctl delbr virbr0
</code></pre></div><h4 id=the-manual-way>The Manual Way</h4><h5 id=initialize-3>Initialize</h5><p>First, move into a new directory and clone the <code>httpreply</code> repo there.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd .. &amp;&amp; mkdir 02-httpreply-manual &amp;&amp; cd 02-httpreply-manual
$ git clone https://github.com/unikraft/app-httpreply .
</code></pre></div><h5 id=adding-a-makefile>Adding a Makefile</h5><p>Unlike before, you can notice that this time we are missing the regular <code>Makefile</code>.
Let&rsquo;s start by copying the <code>Makefile</code> from helloworld:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cp ../01-hello-world/Makefile .
</code></pre></div><p>This is how it looks like:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cat Makefile
UK_ROOT ?= $(PWD)/../../unikraft
UK_LIBS ?= $(PWD)/../../libs
LIBS :=

all:
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)

$(MAKECMDGOALS):
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre></div><p>As you can see, the previously presented environment values make the same wrong assumption.
Previously, we fixed this by preceding the <code>make</code> command with the updated values for the environment variables, but we could have also simply modified them from within the <code>Makefile</code>, like so:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>UK_ROOT ?= $(HOME)/.unikraft/unikraft
UK_LIBS ?= $(HOME)/.unikraft/libs
LIBS :=


	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)

$(MAKECMDGOALS):
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre></div><p>For the HTTP server, however, we need the <code>lwip</code> library, and we have to add it to the <code>LIBS</code> variable in the Makefile.
We add it by first downloading it on our system in <code>$(UK_WORKDIR)/libs/</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ git clone https://github.com/unikraft/lib-lwip ~/.unikraft/libs/lwip
fatal: destination path &#39;~/.unikraft/libs/lwip&#39; already exists and is not an empty directory.
</code></pre></div><p>The library is already cloned. That is because <code>kraft</code> took care of it for us behind the scenes in our previous automatic build.</p><p>The next step is to add this library in the <code>Makefile</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>UK_ROOT ?= $(HOME)/.unikraft/unikraft
UK_LIBS ?= $(HOME)/.unikraft/libs
LIBS := $(UK_LIBS)/lwip

all:
        @$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)

$(MAKECMDGOALS):
        @$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre></div><h5 id=configure-3>Configure</h5><p>Now, we configure it through <code>make menuconfig</code>.</p><p><img src=/getting-started/images/menuconfig_select_lwip.png alt="lwip selection menu"></p><p><img src=/getting-started/images/menuconfig_select_lwip2.png alt="lwip2 selection menu"></p><p>If you noticed, the menu also automatically selected some other internal components that would be required by <code>lwip</code>.
Now <code>Save</code> and <code>Exit</code> the configuration and run <code>make</code>.</p><h5 id=build-3>Build</h5><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make
</code></pre></div><h5 id=run-3>Run</h5><p>To run the KVM image, we use the <code>qemu-system-x86_64</code> command:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ qemu-system-x86_64 -kernel build/02-httpreply-manual_kvm-x86_64 -nographic
[...]
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Listening on port 8123...
</code></pre></div><p>To close the running QEMU process, use the <code>Ctrl+a x</code> key combination.</p><p><strong>Note</strong>: We didn&rsquo;t go into configuring a functional network connection and actually querying the HTTP server.
This is a bit more complicated and is outside the scope of this session.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>sudo qemu-system-x86_64 -netdev bridge,id=en0,br=virbr0 -device virtio-net-pci,netdev=en0 -append &#34;netdev.ipv4_addr=172.44.0.2 netdev.ipv4_gw_addr=172.44.0.1 netdev.ipv4_subnet_mask=255.255.255.0 --&#34; -kernel build/02-httpreply-manual_kvm-x86_64 -nographic
</code></pre></div><h5 id=connecting-to-the-http-server-1>Connecting to the HTTP Server</h5><p>Similarly to kraft, in order to connect to the HTTP server, we use a virtual bridge to create a connection between the VM and the host system.
We assign address <code>172.44.0.1/24</code> to the bridge interface (pointing to the host) and we assign address <code>172.44.0.2/24</code> to the virtual machine, by passing boot arguments.</p><p>We run the commands below to create and assign the IP address to the bridge <code>virbr0</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo brctl addbr virbr0
$ sudo ip a a  172.44.0.1/24 dev virbr0
$ sudo ip l set dev virbr0 up
</code></pre></div><p>Now we start the virtul machine and pass it the proper arguments to assing the IP address <code>172.44.0.2/24</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo qemu-system-x86_64 -netdev bridge,id=en0,br=virbr0 -device virtio-net-pci,netdev=en0 -append &#34;netdev.ipv4_addr=172.44.0.2 netdev.ipv4_gw_addr=172.44.0.1 netdev.ipv4_subnet_mask=255.255.255.0 --&#34; -kernel build/02-httpreply-manual_kvm-x86_64 -nographic
0: Set IPv4 address 172.44.0.2 mask 255.255.255.0 gw 172.44.0.1
en0: Added
en0: Interface is up
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Listening on port 8123...
[...]
</code></pre></div><p>The boot message confirms the assigning of the <code>172.44.0.2/24</code> IP address to the virtual machine.
It&rsquo;s listening on port 8123 for HTTP connections on that IP address.
We use <code>wget</code> to validate it&rsquo;s working properly and we are able to get the <code>index.html</code> file:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ wget 172.44.0.2:8123
--2021-08-18 16:47:38--  http://172.44.0.2:8123/
Connecting to 172.44.0.2:8123... connected.
HTTP request sent, awaiting response... 200 OK
[...]
2021-08-18 16:47:38 (41.5 MB/s) - ‘index.html’ saved [160]
</code></pre></div><p>Cleaning up means closing the virtual machine (and the HTTP server) and disabling and deleting the bridge interface:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ sudo ip l set dev virbr0 down
$ sudo brctl delbr virbr0
</code></pre></div><h2 id=summary>Summary</h2><p><code>kraft</code>is an extremely useful tool for quickly deploying unikernel images.
It abstracts away many factors that would normally increase the difficulty of such tasks.
Through just a simple set of a few commands, we can build and run a set of fast and secure unikernel images with low memory footprint.</p><h2 id=practical-work>Practical Work</h2><h3 id=01-echo-back-server>01. Echo-back Server</h3><p>You will have to implement a simple echo-back server in C for the KVM platform.
The application will have to be able to open a socket on <code>172.44.0.2:1234</code> and send back to the client whatever the client sends to the server.
If the client closes the connection, the server will automatically close.</p><p>Enter the <code>work/01-echo-back/</code> directory.
Check the source code file (<code>main.c</code>) and support files.
Work on the contents to have a viable echo-back server implementation.
Things to consider:</p><ul><li>You will need some network client utility such as <code>netcat</code>.</li><li>You will need the Lightweight TCP/IP stack library (lwip): <a href=https://github.com/unikraft/lib-lwip>https://github.com/unikraft/lib-lwip</a></li><li>You will have to update the build and support files in the <code>work/01-echo-back/</code> directory.</li><li>If you want to run the application without <code>kraft</code>, the KVM launch script and network setup are already included inside <code>work/01-echo-back/launch.sh</code>.</li></ul><p>To test if your application works you can try sending it messages like so:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ nc 172.44.0.2 1234
</code></pre></div><p>After connecting to the server, whatever you enter in standard input, should be echoed back to you.</p><h3 id=02-rot-13>02. ROT-13</h3><p>Update the previously built application, to echo back a <code>rot-13</code> encoded message.
To do this, you will have to create a custom function inside <code>lwip</code> (<code>~/.unikraft/libs/lwip/</code>) that your application (from the new directory <code>work/02-rot13</code>) can call in order to encode the string.
For example, you could implement the function <code>void rot13(char *msg);</code> inside <code>~/.unikraft/libs/lwip/sockets.c</code> and add its header inside <code>~/.unikraft/libs/lwip/include/sys/socket.h</code>.</p><p>The required resources are the exact same as in the previous exercise, you will just have to update <code>lwip</code>.
To test if this works, use the same methodology as before, but ensure that the echoed back string is encoded.</p><h3 id=03-tutorial-mount-9pfs>03. Tutorial: Mount 9pfs</h3><p>In this tutorial, we will see what we would need to do if we wanted to have a filesystem available.
To make it easy, we will use the <code>9pfs</code> filesystem, as well as the <code>newlib</code> library.
The latter is used so that we have available an API that would enable us to interact with this filesystem (functions such as <code>lseek</code>, <code>open</code>).</p><p><strong>Note</strong>: the build will fail if <code>unikraft</code> and <code>newlib</code> repositories aren&rsquo;t both on the <code>staging</code> or the <code>stable</code> branches.
To avoid this situation, go to <code>~/.unikraft/unikraft</code> and checkout branch <code>staging</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>cd ~/.unikraft/unikraft
git checkout staging
</code></pre></div><p>We will need to download <code>newlib</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>git clone https://github.com/unikraft/lib-newlib.git ~/.unikraft/libs/newlib
</code></pre></div><p>Next, we include it in our <code>Makefile</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>LIBS := $(UK_LIBS)/lwip:$(UK_LIBS)/newlib
</code></pre></div><p>And now, for the final step, through <code>make menuconfig</code> make sure you have selected <code>libnewlib</code> as well as <code>9pfs: 9p filesystem</code> inside the <code>Library Configuration</code> menu.
We will also check these options inside <code>Library Configuration</code> -> <code>vfscore: Configuration</code>:</p><p><img src=/getting-started/images/menuconfig_select_fs.png alt="fs selection menu"></p><p><img src=/getting-started/images/menuconfig_select_fs2.png alt="fs2 selection menu"></p><p><img src=/getting-started/images/menuconfig_select_fs3.png alt="fs3 selection menu"></p><p>What is more, you should also have present in the current directory an additional directory called <code>fs0</code>:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>mkdir fs0
</code></pre></div><p>And so, <code>fs0</code> will contain whatever files you create, read from or write to from within your unikernel.</p><p>For now, just make sure it successfully builds. If it does, move on to the next work item.</p><h3 id=04-store-strings>04. Store Strings</h3><p>For the final work item, you will have to update the source code from the second task, so that it stores in a file the received string before sending the encoded one back to the client.
In order to achieve this, you must have the previous work item completed.</p><p>The available resources are the exact same, you will simply have to modify <code>main.c</code>.</p><p>To test if your application ran successfully, check to see whether the original strings you sent through the client are present in that file or not.</p><h2 id=further-reading>Further Reading</h2><p><a href=http://docs.unikraft.org/index.html>Unikraft Documentation</a></p></div></div></div></div></div></div><footer class=sub-footer><div class="container py-5"><div class=row><div class="col-12 col-md">Unikraft
<small class="d-block mb-3 text-muted">© 2021</small></div><div class="col-6 col-md"><h5>Social</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://twitter.com/UnikraftSDK>Twitter</a></li><li><a class=text-muted href=https://www.linkedin.com/company/unikraft-sdk/>LinkedIn</a></li></ul></div><div class="col-6 col-md"><h5>&nbsp;</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://bit.ly/UnikraftDiscord>Discord</a></li><li><a class=text-muted href=https://github.com/unikraft/unikraft>GitHub</a></li></ul></div><div class="col-6 col-md"><h5>Resources</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://unikraft.org>Unikraft Homepage</a></li><li><a class=text-muted href=https://unikraft.io>Unikraft Cloud</a></li></ul></div><div class="col-6 col-md"><h5>&nbsp;</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=http://docs.unikraft.org>Documentation</a></li><li><a class=text-muted href=https://unikraft.org/license/>Open-Source Licenses</a></li></ul></div></div></footer></div><script type=text/javascript src=/js/scripts.min.eaf147370baecdd07c022597db631f99cab1c9cd6479de586f30327a568d6a0f.js></script></body></html>