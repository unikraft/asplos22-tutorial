<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>Running complex applications - ASPLOS'22 Tutorial</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Unikraft ASPLOS'22 Tutorial"><meta property="og:title" content="Unikraft ASPLOS'22 Tutorial"><meta property="og:type" content="website"><meta property="og:url" content="https://asplos22.unikraft.org"><meta property="og:description" content="ASPLOS'22 Tutorial on Unikraft: educating the community on unikernels, libOSes, and particularly Unikraft."><meta name=twitter:card content="summary"><meta name=twitter:site content="@UnikraftSDK"><meta name=twitter:creator content="@UnikraftSDK"><link rel=icon href=/favicon.png><link rel=stylesheet href=/css/style.min.9d91cadd6bf9a027131051416b1155705f1a4ce3735fcdef7072384726bf9590.css></head><body class="page page-default-single"><div id=main-menu-mobile class=main-menu-mobile><ul><li class="menu-item-learn more about unikraft"><a href=https://unikraft.org><span>Learn more about Unikraft</span></a></li></ul></div><div class=wrapper><div class=header><div class=container><div class=logo><a href=/><img alt=Logo src=/images/unikraft.svg>
<span>ASPLOS'22 Tutorial</span></a></div><div class=logo-mobile><a href=/><img alt=Logo src=/images/unikraft.svg>
<span>ASPLOS'22 Tutorial</span></a></div><div id=main-menu class=main-menu><ul><li class="menu-item-learn more about unikraft"><a href=https://unikraft.org><span>Learn more about Unikraft</span></a></li></ul></div><button id=toggle-main-menu-mobile class="hamburger hamburger--slider" type=button>
<span class=hamburger-box><span class=hamburger-inner></span></span></button></div></div><div class="container pt-2 pt-md-4 pb-3 pb-md-6"><div class=row><div class="col-12 col-md-3 mb-3"><div class=sidebar><div class=docs-menu><h4></h4><ul><li><a href=/intro/>Introduction to Unikraft</a></li><li><a href=/getting-started/>Getting started with Unikraft</a></li><li><a href=/a-look-inside/>Inside the Config and Build System</a></li><li class=active><a href=/complex-apps/>Running complex applications</a></li><li><a href=/syscall_shim-bincompat/>Syscall Shim and Binary Compatibility Layer</a></li><li><a href=/high-performance/>High performance applications</a></li><li><a href=/current-research-and-dev/>Unikernels: Paths to Production & Current Research Trends</a></li><li><a href=/people/>People</a></li></ul></div></div></div><div class="col-12 col-md-9"><h1 class=title>Running complex applications</h1><div class=content><h2 id=work-items>Work Items</h2><p>In this session, we are going to run some real-world applications on top of Unikraft.</p><h3 id=support-files>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/asplos22-tutorial>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/complex-apps/

$ ls -F
images/  index.md  sol/  work/
</code></pre></div><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ git clone https://github.com/unikraft/asplos22-tutorial

$ cd summer-of-code-2021/content/en/complex-apps/

$ ls -F
images/  index.md  sol/  work/
</code></pre></div><h3 id=00-qemu-wrapper>00. Qemu Wrapper</h3><p>As we saw during the other sessions, <a href=https://github.com/unikraft/kraft/blob/staging/scripts/qemu-guest>qemu-guest</a> is a wrapper script over the <code>qemu-system-x86_64</code> executable, to make the use of binary less painful.
In the following session, it will be very handy to use it.
To see the options for this wrapper you can use <code>qemu-guest -h</code>.</p><p>It is possible to run a lot of complex applications on Unikraft.
In this session we analyze 3 of them:</p><ul><li>Sqlite</li><li>Redis</li><li>Nginx</li></ul><h3 id=01-sqlite-tutorial>01. SQLite (Tutorial)</h3><p>The goal of this tutorial is to get you to set up and run SQLite on top of Unikraft.
Find the support files in the <code>work/01-set-up-and-run-sqlite/</code> folder of the session directory.</p><p><a href=https://www.sqlite.org/index.html>SQLite</a> is a C library that implements an encapsulated SQL database engine that does not require any setting or administration.
It is one of the most popular in the world and is different from other SQL database engines because it is simple to administer, use, maintain, and test.
Thanks to these features, SQLite is a fast, secure, and most crucial simple application.</p><p>The SQLite application is formed by a ported external library that depends on two other libraries that are also ported for Unikraft: <a href=https://github.com/unikraft/lib-pthread-embedded>pthread-embedded</a> and <a href=https://github.com/unikraft/lib-newlib>newlib</a>.
To successfully compile and run the SQLite application for the KVM platform and x86-64 architecture, we follow the steps below.</p><h4 id=setup>Setup</h4><p>First, we make sure we have the directory structure to store the local clones of Unikraft, library and application repositories.
The structure should be:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>workdir
|-- unikraft/
|-- libs/
`-- apps/
</code></pre></div><p>We clone the <a href=https://github.com/unikraft/lib-sqlite>lib-sqlite</a> repository in the <code>libs/</code> folder.
The libraries on which <code>lib-sqlite</code> depends (<a href=https://github.com/unikraft/lib-newlib>pthread-embedded</a> and <a href=https://github.com/unikraft/lib-pthread-embedded>newlib</a>) are also to be cloned in the <code>libs/</code> folder.</p><p>We clone the <a href=https://github.com/unikraft/app-sqlite/>app-sqlite</a> repository in the <code>apps/</code> folder.
In this directory, we need to create two files:</p><ul><li><code>Makefile</code>: containing rules for building the application as well as specifying the libraries that the application needs</li><li><code>Makefile.uk</code>: used to define variables needed to compile the application or to add application-specific flags</li></ul><p>Also, in the <code>Makefile</code>, the order in which the libraries are mentioned in the <code>LIBS</code> variable is important to avoid the occurrence of compilation errors.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>UK_ROOT ?= $(PWD)/../../unikraft
UK_LIBS ?= $(PWD)/../../libs
LIBS := $(UK_LIBS)/lib-pthread-embedded:$(UK_LIBS)/lib-newlib:$(UK_LIBS)/lib-sqlite

all:
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)

$(MAKECMDGOALS):
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre></div><h4 id=configure>Configure</h4><p>We configure the application by running:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div><p>We select the SQLite library from the configuration menu, <code>Library Configuration</code> section.
For starters, we select the option to generate the main source file used to run the application.</p><p>To import or export databases or CSV/SQL files, the SQLite application needs to configure a filesystem.
The filesystem we use is 9pfs.
Hence, in the <code>Library Configuration</code> section, we select the <code>9pfs</code> filesystem within the <code>vfscore</code> library options.</p><p>Make sure, that both options <code>Virtio PCI device support</code> and <code>Virtio 9P device</code> are selected.
Those can be found in: <code>Platform Configuration</code> -> <code>KVM guest</code> -> <code>Virtio</code>.</p><p><img src=/complex-apps/images/9pfs_options.png alt="9pfs options"></p><h4 id=build>Build</h4><p>We build the application by running:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make
</code></pre></div><h4 id=test>Test</h4><p>For testing we can use the following SQLite script, which inserts ten values into a table:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>CREATE TABLE tab (d1 int, d2 text);
INSERT INTO tab VALUES (random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text));
</code></pre></div><p>Up next, create a folder in the application folder called <code>sqlite_files</code> and write the above script into a file.
When you run the application, you can specify the path of the newly created folder to the <code>qemu-guest</code> as following:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ./qemu-guest -k ./build/app-sqlite_kvm-x86_64 \
               -e ./sqlite_files \
               -m 500
</code></pre></div><p>The SQLite start command has several parameters:</p><ul><li><code>k</code> indicates the executable resulting from the build of the entire system together with the <code>SQLite application</code></li><li><code>e</code> indicates the path to the shared directory where the Unikraft filesystem will be mounted</li><li><code>m</code> indicates the memory allocated to the application</li></ul><p>To load the SQLite script, we use the following command <code>.read &lt;sqlite_script_name.sql></code>.
And in the end, we run <code>select * from tab</code> to see the contents of the table.</p><p>If everything runs as expected, then we&rsquo;ll see the following output:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>SeaBIOS (version 1.10.2-1ubuntu1)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~825b115
SQLite version 3.30.1 2019-10-10 20:19:45
Enter &#34;.help&#34; for usage hints.
sqlite&gt; .read script.sql
sqlite&gt; select * from tab;
-4482895989777805454|-110319092326802521
1731384004930241734|4521105937488475129
394829130239418471|-5931220326625632549
4715172377251814631|3421393665393635031
2633802986882468389|174376437407985264
-1691186051150364618|3056262814461654943
-4054754806183404125|-2391909815601847844
-4437812378917371546|-6267837926735068846
8830824471222267926|7672933566995619644
4185269687730257244|-3477150175417807640
sqlite&gt;
</code></pre></div><h3 id=02-sqlite-new-filesystem-tutorial>02. SQLite New Filesystem (Tutorial)</h3><p>In the previous work item, we have chosen to use 9PFS as the filesystem.
For this work item, we want to change the filesystem to RamFS and load the SQLlite script as we have done in the previous work item.
Find the support files in the <code>work/02-change-filesystem-sqlite/</code> folder of the session directory.</p><p>First, we need to change the filesystem to InitRD.
We can obtain that by using the command <code>make menuconfig</code> and from the <code>vfscore: Configuration</code> option, we select the default root filesystem as <code>InitRD</code>.</p><p><img src=/complex-apps/images/filesystems.png alt="filesystems menu"></p><p>The InitRD filesystem can load only <a href="https://www.ibm.com/docs/en/zos/2.2.0?topic=formats-cpio-format-cpio-archives">cpio archives</a>, so to load our SQLite script into RamFS filesystem, we need to create a cpio out of it.
This can be achieved the following way: Create a folder, move the SQLite script in it, and <code>cd </code>in it.
After that we run the following command:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ find -type f | bsdcpio -o --format newc &gt; ../archive.cpio
</code></pre></div><p>We&rsquo;ll obtain an cpio archive called <code>archive.cpio</code> in the parent directory.</p><p>Next we run the following qemu command to run the instance:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ./qemu-guest -k build/app-sqlite_kvm-x86_64 -m 100 -i archive.cpio
</code></pre></div><p>If everything runs as expected, then we&rsquo;ll see the following output:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>SeaBIOS (version 1.10.2-1ubuntu1)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ &#39; _) :_
oO   oO &#39; _ `| | |/ /  _)&#39; _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~825b115
SQLite version 3.30.1 2019-10-10 20:19:45
Enter &#34;.help&#34; for usage hints.
sqlite&gt; .read script.sql
sqlite&gt; select * from tab;
-4482895989777805454|-110319092326802521
1731384004930241734|4521105937488475129
394829130239418471|-5931220326625632549
4715172377251814631|3421393665393635031
2633802986882468389|174376437407985264
-1691186051150364618|3056262814461654943
-4054754806183404125|-2391909815601847844
-4437812378917371546|-6267837926735068846
8830824471222267926|7672933566995619644
4185269687730257244|-3477150175417807640
sqlite&gt;
</code></pre></div><h3 id=03-redis-tutorial>03. Redis (Tutorial)</h3><p>The goal of this tutorial is to get you to set up and run Redis on top of Unikraft.
Find the support files in the <code>work/03-set-up-and-run-redis/</code> folder of the session directory.</p><p><a href=https://redis.io/topics/introduction>Redis</a> is one of the most popular key-value databases, with a design that facilitates the fast writing and reading of data from memory as well as the storage of data on disk to be able to reconstruct the state of data in memory in case of a system restart.
Unlike other data storage systems, Redis supports different types of data structures such as lists, maps, strings, sets, bitmaps, streams.</p><p>The Redis application is formed by a ported external library that depends on other ported libraries for Unikraft (<a href=https://github.com/unikraft/lib-pthread-embedded>pthread-embedded</a>, <a href=https://github.com/unikraft/lib-newlib>newlib</a>, <a href=https://github.com/unikraft/lib-lwip>lwip-network</a> library).
To successfully compile and run the Redis application for the KVM platform and x86-64 architecture, we follow the steps below.</p><h4 id=setup-1>Setup</h4><p>As above, we make sure we have the directory structure to store the local clones of Unikraft, library and application repositories.
The structure should be:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>workdir
|-- unikraft/
|-- libs/
`-- apps/
</code></pre></div><p>We clone the <a href=https://github.com/unikraft/lib-redis>lib-redis</a> repository in the <code>libs/</code> folder.
We alsoe clonethe library repositories which <a href=https://github.com/unikraft/lib-redis>lib-redis</a> depends on ([pthread-embedded](<a href=https://github.com/unikraft/lib-pthread-embedded>pthread-embedded</a>, <a href=https://github.com/unikraft/lib-newlib>newlib</a> and <a href=https://github.com/unikraft/lib-lwip>lwip</a>) in the <code>libs/</code> folder.</p><p>We clone the <a href=https://github.com/unikraft/app-redis/>app-redis</a> repository in the <code>apps/</code> folder.
In this directory, we need to create two files:</p><ul><li><code>Makefile</code>: it contains rules for building the application as well as specifying the libraries that the application needs</li><li><code>Makefile.uk</code>: used to define variables needed to compile the application or to add application-specific flags</li></ul><p>Also, in the <code>Makefile</code>, the order in which the libraries are mentioned in the <code>LIBS</code> variable is important to avoid the occurrence of compilation errors.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>UK_ROOT ?= $(PWD)/../../unikraft
UK_LIBS ?= $(PWD)/../../libs
LIBS := $(UK_LIBS)/lib-pthread-embedded:$(UK_LIBS)/lib-newlib:$(UK_LIBS)/lib-lwip:$(UK_LIBS)/lib-redis

all:
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)

$(MAKECMDGOALS):
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre></div><h4 id=configure-1>Configure</h4><p>We configure the application by running:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make menuconfig
</code></pre></div><p>We select the Redis library from the configuration menu, <code>Library Configuration</code> section.
For starters, we select the option to generate the main source file used to run the application.</p><p><img src=/complex-apps/images/redis_menu.png alt="redis selection menu"></p><h4 id=build-1>Build</h4><p>We build the application by running:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ make
</code></pre></div><h4 id=test-1>Test</h4><p>To connect to the Redis server, the network features should be configured.
Hence, in the configuration menu in the <code>Library Configuration</code> section, within the <code>lwip library</code> the following options should be selected:</p><ul><li><code>IPv4</code></li><li><code>UDP support</code></li><li><code>TCP support</code></li><li><code>ICMP support</code></li><li><code>DHCP support</code></li><li><code>Socket API</code></li></ul><p><img src=/complex-apps/images/lwip_redis_menu.png alt="lwip selection menu"></p><p>The Redis application needs a configuration file to start.
Thus, a filesystem should be selected in Unikraft.
The filesystem we used was 9PFS.
So, in the <code>Library Configuration</code> section of the configuration menu, the following selection chain should be made in the vfscore library: <code>VFSCore Interface</code> -> <code>vfscore Configuration</code> -> <code>Automatically mount a root filesystem</code> -> <code>Default root filesystem</code> -> <code>9PFS</code>.</p><p>Therefore, following the steps above, the build of the entire system, together with the Redis application will be successful.
We used a script to run the application in which a bridge and a network interface (<code>kraft0</code>) are created.
The network interface has an IP associated with it used by clients to connect to the Redis server.
Also, the script takes care of starting the Redis server, but also of stopping it, deleting the settings created for the network.</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>brctl addbr kraft0
ifconfig kraft0 172.44.0.1
ifconfig kraft0 up

dnsmasq -d \
        --log-queries \
        --bind-dynamic \
        --interface=kraft0 \
        --listen-addr=172.44.0.1 \
        --dhcp-range=172.44.0.2,172.44.0.254,255.255.255.0,12h &amp;&gt; $WORKDIR/dnsmasq.log &amp;

./qemu-guest.sh -k ./build/redis_kvm-x86_64 \
                -a &#34;/redis.conf&#34; \
                -b kraft0 \
                -e ./redis_files
                -m 100
</code></pre></div><p>The Redis server start command has several parameters:</p><ul><li><code>k</code> indicates the executable resulting from the build of the entire system together with the <code>Redis</code> application</li><li><code>e</code> indicates the path to the shared directory where the Unikraft filesystem will be mounted</li><li><code>b</code> indicates the network interface used for external communication</li><li><code>m</code> indicates the memory allocated to the application</li><li><code>a</code> allows the addition of parameters specific to running the application</li></ul><p>The following image is presenting an overview of our setup:</p><p><img src=/complex-apps/images/redis_setup.png alt="lwip selection menu"></p><p>Consequently, after running the script the Redis server will start and dnsmasq will dynamically assign an IP address.
The IP can be seen in the output of qemu as bellow:</p><p><img src=/complex-apps/images/redis_ip.png alt="redis ip"></p><p>Using the received IP, it will be possible to connect clients to it using <code>redis-cli</code> (the binary <code>redis-cli</code> is the folder for this work item):</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ./redis-cli -h 172.88.0.76 -p 6379
172.88.0.2:6379&gt; PING
PONG
172.88.0.2:6379&gt;
</code></pre></div><h3 id=04-redis-static-ip-address>04. Redis Static IP Address</h3><p>In tutorial above we have dynamically assigned an IP to the network interface used by Unikraft using the <code>dnsmasq</code> utility.
Find the support files in the <code>work/04-obtain-the-ip-statically/</code> folder of the session directory.</p><p>Modify the launching script and run the application with a static IP.
Beware that the assigned IP address must differ from the one assigned on the bridge.</p><p>You can use <code>redis-cli</code>, found in the suport folder to test your changes.
If everything runs as expected you should see the following output:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ./redis-cli -h 172.88.0.76 -p 6379
172.88.0.2:6379&gt; PING
PONG
172.88.0.2:6379&gt;
</code></pre></div><h3 id=05-redis-benchmarking-tutorial>05. Redis Benchmarking (Tutorial)</h3><p>We aim to do benchmarking for the Redis app running on top of Unikraft and for the Redis running on top of Linux.
Find the support files in the <code>work/05-benchmark-redis/</code> folder of the session directory.
There are three binaries: <code>redis-cli</code>, <code>redis-benchmark</code>, and <code>redis</code>.</p><p>First, we will start by benchmarking <code>redis app</code>, running on Unikraft.
Start the Redis on the top of Unikraft as we have already done at above and in another terminal run the following command:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ./redis-benchmark --csv -q -r 100 -n 10000 -c 1 -h 172.44.0.76 -p 6379 -P 8 -t set,get
</code></pre></div><p>The description of the used option can be seen here:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>Usage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests&gt;] [-k &lt;boolean&gt;]

 -h &lt;hostname&gt;      Server hostname (default 127.0.0.1)
 -p &lt;port&gt;          Server port (default 6379)
 -c &lt;clients&gt;       Number of parallel connections (default 50)
 -n &lt;requests&gt;      Total number of requests (default 100000)
 -P &lt;numreq&gt;        Pipeline &lt;numreq&gt; requests. Default 1 (no pipeline).
 -q                 Quiet. Just show query/sec values
 --csv              Output in CSV format
 -t &lt;tests&gt;         Only run the comma separated list of tests. The test
                    names are the same as the ones produced as output.
</code></pre></div><p>If everything runs as expected, you&rsquo;ll see the following output:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>&#34;SET&#34;,&#34;147058.81&#34;
&#34;GET&#34;,&#34;153846.16&#34;
</code></pre></div><p>The printed values represent <code>requests/second</code> for the operation <code>set</code> and <code>get</code>.</p><p>Further, we will run the executable <code>redis-server</code> (<code>./redis-server</code>), which can be found in the support folder, and the following command (only the IP address of the redis server was changed):</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>$ ./redis-benchmark --csv -q -r 100 -n 10000 -c 1 -h 127.0.0.1 -p 6379 -P 8 -t set,get
</code></pre></div><p>After that you&rsquo;ll get something like this:</p><div class=highlight><pre class=chroma><code class=language-fallback data-lang=fallback>&#34;SET&#34;,&#34;285714.28&#34;
&#34;GET&#34;,&#34;294117.62&#34;
</code></pre></div></div></div></div></div></div></div><footer class=sub-footer><div class="container py-5"><div class=row><div class="col-12 col-md">Unikraft
<small class="d-block mb-3 text-muted">© 2021</small></div><div class="col-6 col-md"><h5>Social</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://twitter.com/UnikraftSDK>Twitter</a></li><li><a class=text-muted href=https://www.linkedin.com/company/unikraft-sdk/>LinkedIn</a></li></ul></div><div class="col-6 col-md"><h5>&nbsp;</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://bit.ly/UnikraftDiscord>Discord</a></li><li><a class=text-muted href=https://github.com/unikraft/unikraft>GitHub</a></li></ul></div><div class="col-6 col-md"><h5>Resources</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=https://unikraft.org>Unikraft Homepage</a></li><li><a class=text-muted href=https://unikraft.io>Unikraft Cloud</a></li></ul></div><div class="col-6 col-md"><h5>&nbsp;</h5><ul class="list-unstyled text-small"><li><a class=text-muted href=http://docs.unikraft.org>Documentation</a></li><li><a class=text-muted href=https://unikraft.org/license/>Open-Source Licenses</a></li></ul></div></div></footer></div><script type=text/javascript src=/js/scripts.min.eaf147370baecdd07c022597db631f99cab1c9cd6479de586f30327a568d6a0f.js></script></body></html>